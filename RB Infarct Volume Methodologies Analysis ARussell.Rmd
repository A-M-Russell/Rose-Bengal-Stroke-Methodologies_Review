---
title: "Rose Bengal Infarct Volume Analysis"
author: "Ash A. M. Russell"
date: "2022-11-28"
output: html_document
editor_options: 
  chunk_output_type: inline
---

All code for meta-analysis investigating how methodologies affect infarct volume in Rose Bengal model of stroke. This analysis summarises Rose Bengal stroke methodologies and creates predictions on how they influence final infarct volume. 
Requires two .csv excel files, Russell_Data_Extraction_Rose_Bengal_11.csv and Russell_Rose_Bengal_Quality_2.csv
Can also use the pre-run workspace file to save time running the code: RB_controls_data.RData
Markdown file started on 28/11/2022, last updated 16/09/2023 

This analysis is the second half of a two-part analysis of Rose Bengal stroke literature. The first half assesses treatment efficacy. The protocol for both these analyses is available on PROSPERO at http://www.crd.york.ac.uk/PROSPERO/display_record.php?ID=CRD42019115429

Updated code, data, and information on this analysis can be found at https://github.com/A-M-Russell/Rose-Bengal-Stroke-Methodologies_Review

Code chunks with plot outputs are set to eval=FALSE so they won't produce plots unless you run them deliberately.
Most chunks are set to include=FALSE so the code will run but the outputs won't print in a knitted file to reduce the output file length. Remove this for any sections you wish to output into a knitted file.

```{r setup, include=FALSE, warning=FALSE}
#check if packages are installed, if not, install them
if(!require(MASS)) install.packages("MASS")
if(!require(sjPlot)) install.packages("sjPlot")
if(!require(ggplot2)) install.packages("ggplot2")
if(!require(emmeans)) install.packages("emmeans")
if(!require(viridis)) install.packages("viridis")
if(!require(dplyr)) install.packages("dplyr")
if(!require(ggfortify)) install.packages("ggfortify")
if(!require(stringr)) install.packages("stringr")
if(!require(tidyr)) install.packages("tidyr")
if(!require(fitdistrplus)) install.packages("fitdistrplus")
if(!require(olsrr)) install.packages("olsrr")
if(!require(betareg)) install.packages("betareg")
if(!require(corrplot)) install.packages("corrplot")
if(!require(car)) install.packages("car")

#load required packages
library(betareg); # for model data which fits a beta distribution
library(ggplot2); # obviously
library(sjPlot); # for easy to read model outputs
library(ggfortify); # for prettier diagnostic plots
library(MASS); # for boxcox transformation + generating example distributions
library(emmeans); #for pot-hocs
library(dplyr); #supposed to be called in tidyr but wasn't?
library(tidyr); # obviously
library(stringr); # searching within text #supposed to be called in tidyr but wasn't?
library(fitdistrplus); # fit distribution, fitting a beta/normal dist to data, for our plots
library(olsrr); # ordinarily squared regression in r - gives us new outlier plots
library(corrplot); #for correlation plot
library(viridis); # colours for plots
library(car); #for regression, has a type 3 Anova function (order of variables doesn't matter)

```

```{r data_import, include=FALSE}
#importing main dataset
dfc3_Raw <- read.csv("Russell_Data_Extraction_Rose_Bengal_12.csv")
#when importing this csv, remember to delete blank studies at end and irrelevant admin variables on right
dfc3 <- dfc3_Raw #copy the raw data frame to make changes to variables, keeping dfc3_Raw as a control to fix mistakes

#importing CAMARADES quality assessment data
dfc3_Quality <- read.csv("Russell_Rose_Bengal_Quality_2.csv")

#merging the quality dataframe with the main dataset by publication code
dfc3 <- merge(dfc3, dfc3_Quality)

```

```{r variable_clean, include=FALSE, warning=FALSE}
#cleaning the database and fixing variable classification

#change all relevant "character" variables to "factor" variables
#animal variables
dfc3$Animal <- factor(dfc3$Animal)
dfc3$Strain <- factor(dfc3$Strain)
dfc3$Sex <- factor(dfc3$Sex)
dfc3$Comorbidity <- factor(dfc3$Comorbidity)
dfc3$Comorbidity_induction <- factor(dfc3$Comorbidity_induction)
#stroke model variables
dfc3$Primary_anaesthetic <- factor(dfc3$Primary_anaesthetic)
dfc3$Secondary_anaesthetic <- factor(dfc3$Secondary_anaesthetic)
dfc3$Surgical_level <- factor(dfc3$Surgical_level)
dfc3$Brain_area <- factor(dfc3$Brain_area)
dfc3$Light_type <- factor(dfc3$Light_type)
dfc3$Light_source <- factor(dfc3$Light_source)
as.table(summary(dfc3$Surgical_level))
#treatment variables
dfc3$Treatment <- factor(dfc3$Treatment)
dfc3$Treatment_class <- factor(dfc3$Treatment_class)
dfc3$Treatment_time_class <- factor(dfc3$Treatment_time_class)
#infarct outcome variables
dfc3$Infarct_measurement <- factor(dfc3$Infarct_measurement)
#neuroscore outcome variables
dfc3$Scale_type <- factor(dfc3$Scale_type)
#quality markers
dfc3$X1_Peer_review <- factor(dfc3$X1_Peer_review)
dfc3$X2_Body_temp <- factor(dfc3$X2_Body_temp)
dfc3$X3_Random_allocation <- factor(dfc3$X3_Random_allocation)
dfc3$X4_Blinded_allocation <- factor(dfc3$X4_Blinded_allocation)
dfc3$X5_Blinded_assessment <- factor(dfc3$X5_Blinded_assessment)
dfc3$X7_Model_comorbidity <- factor(dfc3$X7_Model_comorbidity)
dfc3$X8_Power_calc <- factor(dfc3$X8_Power_calc)
dfc3$X9_Animal_ethics <- factor(dfc3$X9_Animal_ethics)
dfc3$X10_Disclosure_statement <- factor(dfc3$X10_Disclosure_statement)

#change all relevant "character" variables to "numeric"
#age variables
dfc3$Age_weeks_min <- as.numeric(dfc3$Age_weeks_min)
dfc3$Age_weeks_mean <- as.numeric(dfc3$Age_weeks_mean)
dfc3$Age_weeks_max <- as.numeric(dfc3$Age_weeks_max)
#weight variables
dfc3$Weight_g_min <- as.numeric(dfc3$Weight_g_min)
dfc3$Weight_g_mean <- as.numeric(dfc3$Weight_g_mean)
dfc3$Weight_g_max<- as.numeric(dfc3$Weight_g_max)
#animal groups and n variables
dfc3$N_animals_control <- as.numeric(dfc3$N_animals_control)
dfc3$N_treatment_groups <- as.numeric(dfc3$N_treatment_groups)
dfc3$N_animals_treatment <- as.numeric(dfc3$N_animals_treatment)
#stroke model variables
dfc3$RB_dose <- as.numeric(dfc3$RB_dose)
dfc3$Light_wavelength <- as.numeric(dfc3$Light_wavelength)
dfc3$Light_aperture <- as.numeric(dfc3$Light_aperture)
dfc3$Light_time <- as.numeric(dfc3$Light_time)
#treatment variables
dfc3$Treatment_dose <- as.numeric(dfc3$Treatment_dose)
dfc3$Treatment_initial_hour <- as.numeric(dfc3$Treatment_initial_hour)
#infarct outcome variables
dfc3$Infarct_time <- as.numeric(dfc3$Infarct_time)
dfc3$Infarct_mean_control <- as.numeric(dfc3$Infarct_mean_control)
dfc3$Infarct_error_control <- as.numeric(dfc3$Infarct_error_control)
dfc3$Infarct_mean_treatment <- as.numeric(dfc3$Infarct_mean_treatment)
dfc3$Infarct_error_treatment <- as.numeric(dfc3$Infarct_error_treatment)
dfc3$Infarct_diff_from_control <- as.numeric(dfc3$Infarct_diff_from_control)
dfc3$Infarct_diff_from_control_error <- as.numeric(dfc3$Infarct_diff_from_control_error)
dfc3$Infarct_SD_treatment <- as.numeric(dfc3$Infarct_SD_treatment)
#neuroscore outcome variables
dfc3$Scale_score_control <- as.numeric(dfc3$Scale_score_control)
dfc3$Scale_error_control <- as.numeric(dfc3$Scale_error_control)
dfc3$Scale_score_treatment <- as.numeric(dfc3$Scale_score_treatment)
dfc3$Scale_error_treatment <- as.numeric(dfc3$Scale_error_treatment)
dfc3$Scale_time <- as.numeric(dfc3$Scale_time)

```

```{r variable_creation, include=FALSE}

#create Standard Error of the Means variable for infarct volume percent of whole brain
dfc3$Infarct_SEM_control_percent<-dfc3$Infarct_SD_control_percent/sqrt(dfc3$N_animals_control)

#creating anaesthetic variable with multiple anaesthetics combined
dfc3$Anaesthetic <- 
  paste(dfc3$Primary_anaesthetic, 
        coalesce(dfc3$Secondary_anaesthetic, ""))
dfc3$Anaesthetic <- dfc3$Anaesthetic %>%
  str_trim() %>% #trims whitespace from start and end of string
  factor() %>% #make a factor
  na_if("NA") #changes all factor NA's to logical NA's
dfc3$Anaesthetic[dfc3$Anaesthetic=="NR"] <- "Not reported"
#fix anaesthetics that are the same but have mirrored names
dfc3$Anaesthetic[dfc3$Anaesthetic=="Ether Chloral hydrate"] <- "Chloral hydrate Ether"
dfc3$Anaesthetic <- droplevels(dfc3$Anaesthetic) #drop empty levels created above

#making some categorical variables out of continuous ones
#light aperture
summary(dfc3$Light_aperture)
hist(dfc3$Light_aperture, breaks = 12)
dfc3$Light_aperture_cat <- cut(dfc3$Light_aperture,
              breaks=c(0, 1, 2, 3, 4, 5, 11),
              labels=c('0.02-1mm', '1-2mm', '2-3mm', '3-4mm', '4-5mm', '5+mm'))
summary(dfc3$Light_aperture_cat)

#RB dose
summary(dfc3$RB_dose_mgkg)
hist(dfc3$RB_dose_mgkg, breaks = 12)
dfc3$RB_dose_mgkg_cat <- cut(dfc3$RB_dose_mgkg,
              breaks=c(0, 15, 30, 45, 60, 75, 151),
              labels=c('0.1-15mg/kg', '15-30mg/kg', '30-45mg/kg', '45-60mg/kg', '60-75mg/kg', '75+mg/kg'))
summary(dfc3$RB_dose_mgkg_cat)

#light wavelength
summary(dfc3$Light_wavelength)
hist(dfc3$Light_wavelength)
dfc3$Light_wavelength_cat <- cut(dfc3$Light_wavelength,
              breaks=c(450, 500, 550, 600, 801),
              labels=c('450-500nm', '500-550nm', '550-600nm', '600+nm'))
summary(dfc3$Light_wavelength_cat)

#light time (in minutes)
summary(dfc3$Light_time)
hist(dfc3$Light_time, breaks = 10)
dfc3$Light_time_cat <- cut(dfc3$Light_time,
              breaks=c(0, 5, 10, 15, 20, 61),
              labels=c('0.5-5mins', '5-10mins', '10-15mins', '15-20mins', '20+mins'))
summary(dfc3$Light_time_cat)

#light intensity (in W/cm^2)
summary(dfc3$Light_intensity_Wcm2)
hist(dfc3$Light_intensity_Wcm2, breaks = 100)
dfc3$Light_intensity_cat <- cut(dfc3$Light_intensity_Wcm2,
              breaks=c(0, 0.5, 1, 10, 111),
              labels=c('0.0002-0.5 W/cm^2', '0.5-1 W/cm^2', '1-10 W/cm^2', '10+ W/cm^2'))
summary(dfc3$Light_intensity_cat)

```

```{r variable_creation_dummy_anaesthetic, include=FALSE}
#Making dummy variables for most common anaesthetics to use later
#Anaesthetics with their own dummy variable: Chloral hydrate, Enflurane, Halothane, Isoflurane, Ketamine, Nitrous oxide, NR, Sodium Pentobarbital, Tiletamine-Zolazepam, Xylazine

dfc3$Isoflurane<-rep(0, nrow(dfc3)) #make a column called "Isoflurane" and populate it with zeros
dfc3$Isoflurane<-(dfc3$Primary_anaesthetic=="Isoflurane"|dfc3$Secondary_anaesthetic== "Isoflurane")*1 #if the primary or secondary anaesthetic is isoflurane, times it by 1
dfc3$Isoflurane[is.na(dfc3$Isoflurane)]<-0 #because the previous step produces a bunch of NAs, convert NAs back to 0

#repeat for other anaesthetics
dfc3$Chloral_hydrate<-rep(0, nrow(dfc3))
dfc3$Chloral_hydrate<-(dfc3$Primary_anaesthetic=="Chloral hydrate"|dfc3$Secondary_anaesthetic== "Chloral hydrate")*1 
dfc3$Chloral_hydrate[is.na(dfc3$Chloral_hydrate)]<-0 

dfc3$Enflurane<-rep(0, nrow(dfc3))
dfc3$Enflurane<-(dfc3$Primary_anaesthetic=="Enflurane"|dfc3$Secondary_anaesthetic== "Enflurane")*1 
dfc3$Enflurane[is.na(dfc3$Enflurane)]<-0 

dfc3$Halothane<-rep(0, nrow(dfc3))
dfc3$Halothane<-(dfc3$Primary_anaesthetic=="Halothane"|dfc3$Secondary_anaesthetic== "Halothane")*1 
dfc3$Halothane[is.na(dfc3$Halothane)]<-0 

dfc3$Ketamine<-rep(0, nrow(dfc3))
dfc3$Ketamine<-(dfc3$Primary_anaesthetic=="Ketamine"|dfc3$Secondary_anaesthetic== "Ketamine")*1 
dfc3$Ketamine[is.na(dfc3$Ketamine)]<-0 

dfc3$Nitrous_oxide<-rep(0, nrow(dfc3))
dfc3$Nitrous_oxide<-(dfc3$Primary_anaesthetic=="Nitrous oxide"|dfc3$Secondary_anaesthetic== "Nitrous oxide")*1 
dfc3$Nitrous_oxide[is.na(dfc3$Nitrous_oxide)]<-0

dfc3$Anaesthetic_not_reported<-rep(0, nrow(dfc3))
dfc3$Anaesthetic_not_reported<-(dfc3$Primary_anaesthetic=="NR"|dfc3$Secondary_anaesthetic== "NR")*1 
dfc3$Anaesthetic_not_reported[is.na(dfc3$Anaesthetic_not_reported)]<-0 

dfc3$Sodium_pentobarbital<-rep(0, nrow(dfc3))
dfc3$Sodium_pentobarbital<-(dfc3$Primary_anaesthetic=="Sodium Pentobarbital"|dfc3$Secondary_anaesthetic== "Sodium Pentobarbital")*1 
dfc3$Sodium_pentobarbital[is.na(dfc3$Sodium_pentobarbital)]<-0 

dfc3$Tiletamine_Zolazepam<-rep(0, nrow(dfc3))
dfc3$Tiletamine_Zolazepam<-(dfc3$Primary_anaesthetic=="Tiletamine-Zolazepam"|dfc3$Secondary_anaesthetic== "Tiletamine-Zolazepam")*1 
dfc3$Tiletamine_Zolazepam[is.na(dfc3$Tiletamine_Zolazepam)]<-0 

dfc3$Xylazine<-rep(0, nrow(dfc3))
dfc3$Xylazine<-(dfc3$Primary_anaesthetic=="Xylazine"|dfc3$Secondary_anaesthetic== "Xylazine")*1 
dfc3$Xylazine[is.na(dfc3$Xylazine)]<-0 


#Create a dummy variable for other anaesthetics
#Anaesthetics collapsed into an "Other anaesthetics" dummy variable: Alfaxolone/Alfadolone, Atropine, Dexmedetomidine, Equitensine, Equithesin, Ether, Fentanyl/fluanisone, Medetomidine, MS-222, Sevoflurane, Tribromoethanol, Urethane, Zoletil

dfc3$Other_anaesthetics<-rep(0, nrow(dfc3)) #make a column called "Other_anaesthetics" and populate it with zeros
dfc3$Other_anaesthetics<-(dfc3$Primary_anaesthetic=="Alfaxolone/Alfadolone"|
                            dfc3$Secondary_anaesthetic=="Alfaxolone/Alfadolone"|
                            dfc3$Primary_anaesthetic=="Atropine"|
                            dfc3$Secondary_anaesthetic== "Atropine"|
                            dfc3$Primary_anaesthetic=="Dexmedetomidine"|
                            dfc3$Secondary_anaesthetic== "Dexmedetomidine"|
                            dfc3$Primary_anaesthetic=="Equitensine"|
                            dfc3$Secondary_anaesthetic== "Equitensine"|
                            dfc3$Primary_anaesthetic=="Equithesin"|
                            dfc3$Secondary_anaesthetic== "Equithesin"|
                            dfc3$Primary_anaesthetic=="Ether"|
                            dfc3$Secondary_anaesthetic== "Ether"|
                            dfc3$Primary_anaesthetic=="Fentanyl/fluanisone"|
                            dfc3$Secondary_anaesthetic== "Fentanyl/fluanisone"|
                            dfc3$Primary_anaesthetic=="Medetomidine"|
                            dfc3$Secondary_anaesthetic== "Medetomidine"|
                            dfc3$Primary_anaesthetic=="MS-222"|
                            dfc3$Secondary_anaesthetic== "MS-222"|
                            dfc3$Primary_anaesthetic=="Sevoflurane"|
                            dfc3$Secondary_anaesthetic== "Sevoflurane"|
                            dfc3$Primary_anaesthetic=="Tribromoethanol"|
                            dfc3$Secondary_anaesthetic== "Tribromoethanol"|
                            dfc3$Primary_anaesthetic=="Urethane"|
                            dfc3$Secondary_anaesthetic== "Urethane"|
                            dfc3$Primary_anaesthetic=="Zoletil"|
                            dfc3$Secondary_anaesthetic== "Zoletil")*1
dfc3$Other_anaesthetics[is.na(dfc3$Other_anaesthetics)]<-0 #because the previous step produces a bunch of NAs, convert NAs back to 0


```

```{r creating_required_dataframes, include=FALSE}
#dataframe of unique control measures - removes duplicates of all studies that contained multiple experiments but used the same control group for all of them
dfc3_Unique <- dfc3 %>%
  distinct(Publication_code, Infarct_mean_control, Infarct_error_control, .keep_all = TRUE) %>%
  filter(!is.na(Infarct_percent_control) &
           !is.na(Infarct_SD_control_percent) &
           !is.na(N_animals_control))
dfc3_Unique <- droplevels(dfc3_Unique) #drop all the newly empty levels

#dataframe from above unique set but contains only rodents
dfc3_Rodent <- dfc3_Unique %>%
  filter(Animal == "Rat" | Animal == "Mouse")

#dataframe from above unique set but only rats
dfc3_Rat <- dfc3_Unique %>%
  filter(Animal == "Rat")

#dataframe from above unique set but only mice
dfc3_Mouse <- dfc3_Unique %>%
  filter(Animal == "Mouse")

```


# Summary barplot

```{r stacked_barplots_dataset_1, include=FALSE, eval=FALSE}
#note use all relevant papers, not just rodents, so use dfc3_unique
#includes variables: animal species, sex, comorbidities, infarct measurement method, surgical level

dfc3_Barplot <- dfc3_Unique 

#how many unique studies are in these 428 experiments? - 292
dfc3_Unique$Publication_code <- as.factor(dfc3_Unique$Publication_code) #make a factor
dfc3_Unique$Publication_code <- droplevels(dfc3_Unique$Publication_code) #drop empty levels that may have accidentally been created previously
nlevels(as.factor(dfc3_Unique$Publication_code)) #check number of levels to see n of unique studies


#turn all variables in the plot into just two columns to be plotted against each other
dfc3_Barplot <- pivot_longer(dfc3_Barplot, 
                             cols=c(Animal, 
                                    Sex, 
                                    Infarct_measurement, 
                                    Comorbidity, 
                                    Surgical_level), 
                             names_to = "Variable",
                             values_to = "Value", 
                             values_drop_na = FALSE)


#study variables barplot
#reorder levels of variables for study variables barplot
#replace NAs:
dfc3_Barplot$Value[is.na(dfc3_Barplot$Value)] <- "NR"
levels(dfc3_Barplot$Value)[levels(dfc3_Barplot$Value)=="NR"] <- "Not reported"  #replace NR with "Not reported", have to do this using levels otherwise it throws all NRs to NAs

#Re-classify variables
#change small comorbidities to "other"
#"Diabetes", "Hyperglycemia", "Obesity", "Amyloid plaques", "Lupus", "Chronic colitis",   "Immunodeficiency"
levels(dfc3_Barplot$Value)[levels(dfc3_Barplot$Value)=="Diabetes"] <- "Other"
levels(dfc3_Barplot$Value)[levels(dfc3_Barplot$Value)=="Hyperglycemia"] <- "Other"
levels(dfc3_Barplot$Value)[levels(dfc3_Barplot$Value)=="Obesity"] <- "Other"
levels(dfc3_Barplot$Value)[levels(dfc3_Barplot$Value)=="Amyloid plaques"] <- "Other"
levels(dfc3_Barplot$Value)[levels(dfc3_Barplot$Value)=="Lupus"] <- "Other"
levels(dfc3_Barplot$Value)[levels(dfc3_Barplot$Value)=="Chronic colitis"] <- "Other"
levels(dfc3_Barplot$Value)[levels(dfc3_Barplot$Value)=="Immunodeficiency"] <- "Other"

#change small animals to "other"
#"Rabbit", "Primate", "Zebrafish", "Guinea Pig"
levels(dfc3_Barplot$Value)[levels(dfc3_Barplot$Value)=="Rabbit"] <- "Other"
levels(dfc3_Barplot$Value)[levels(dfc3_Barplot$Value)=="Primate"] <- "Other"
levels(dfc3_Barplot$Value)[levels(dfc3_Barplot$Value)=="Zebrafish"] <- "Other"
levels(dfc3_Barplot$Value)[levels(dfc3_Barplot$Value)=="Guinea Pig"] <- "Other"

#Surgical level factors to "other"
levels(dfc3_Barplot$Value)[levels(dfc3_Barplot$Value)=="Scalp and skull intact"] <- "Other"
levels(dfc3_Barplot$Value)[levels(dfc3_Barplot$Value)=="Cranial window (asleep induction)"] <- "Other"
levels(dfc3_Barplot$Value)[levels(dfc3_Barplot$Value)=="Cranial window (awake induction)"] <- "Other"


#re-order the factors
dfc3_Barplot$Variable <- factor(dfc3_Barplot$Variable, levels = c("Animal", "Sex", "Comorbidity", "Infarct_measurement", "Surgical_level"))
dfc3_Barplot$Value <- factor(dfc3_Barplot$Value, levels = c( "Not reported", "Rat",  "Mouse",  "Male", "Female", "Mixed", "None", "Aged", "Hypertension", "TTC (ex vivo)", "Other histology (ex vivo)", "MRI (in vivo)", "Scalp retracted, skull intact" , "Skull thinned", "Skull breached", "Other"))

```

```{r Stacked_barplots_graph_1, include=FALSE, eval=FALSE}

#Barplot on study variables
pdf("Study_variables_barplot_5.pdf", height=5.5, width=7.5)
ggplot(dfc3_Barplot, aes(fill=Value, x=Variable)) + 
  geom_bar(alpha = 0.8) +
  theme_bw() +
  scale_fill_manual(values = c("Not reported" = plasma(3)[1], 
                               "Rat" = plasma(4)[2],  "Mouse" = plasma(4)[3],  
                               "Male" = plasma(5)[2], "Female" = plasma(5)[3], "Mixed" = plasma(5)[4], 
                               "None" = plasma(5)[2], "Aged" = plasma(5)[3], "Hypertension" = plasma(5)[4], 
                               "TTC (ex vivo)" = plasma(5)[2], "Other histology (ex vivo)" = plasma(5)[3], "MRI (in vivo)" = plasma(5)[4],
                               "Scalp retracted, skull intact"= plasma(5)[2], "Skull thinned"= plasma(5)[3], "Skull breached"= plasma(5)[4],
                               "Other"= plasma(9)[9])) +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black")) +
  geom_text(aes(label=Value), stat="count", position = "stack", vjust=1.2) +
  labs(y="Number of experiments", x= "") +
  scale_x_discrete(labels = c("Animal Species", "Animal Sex", "Comorbidity", "Infarct Measurement Method", "Surgical Level")) +
  ylim(-15,440)
dev.off()


```

```{r stacked_barplots_dataset_2, include=FALSE, eval=FALSE}
#methods barplot
#includes variables: anaesthetic, rose bengal dose, light source, light aperture, light exposure time, light wavelength, light intensity

dfc3_Barplot_methods <- dfc3_Unique


#reorder levels of variables for methods barplot + reclassify NA's
levels(dfc3_Barplot_methods$Anaesthetic)[levels(dfc3_Barplot_methods$Anaesthetic)=="None"] <- "Other" #change anaesthetics listed as "none" to "other" - must do this before transforming otherwise both comorbidity and anaesthetics will have a "none" factor and both will be converted to "other" later


#turn all vriables in the plot into just two columns to be plotted against each other
dfc3_Barplot_methods<- pivot_longer(dfc3_Barplot_methods, 
                             cols=c(Anaesthetic,
                                    RB_dose_mgkg_cat, 
                                    Light_source, 
                                    Light_aperture_cat, 
                                    Light_time_cat, 
                                    Light_wavelength_cat, 
                                    Light_intensity_cat), 
                             names_to = "Methods_variable",
                             values_to = "Methods_value", 
                             values_drop_na = FALSE)

#replace NA's with Not Reported (have to do this levels-based approach as replace_na only works for numeric not factors)
dfc3_Barplot_methods$Methods_value[is.na(dfc3_Barplot_methods$Methods_value)] <- "NR" #for some reason won't let me put "Not Reported" here
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="NR"] <- "Not reported" #replace NR with "Not reported", have to do this using levels otherwise it throws all NRs to NAs


#remove factors that are too small to display on graph and recode to "other"
#change small anaesthetics to "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Chloral hydrate Atropine"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Chloral hydrate Ether"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Chloral hydrate Xylazine"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Enflurane"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Equithesin"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Ether Atropine"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Halothane Isoflurane"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Isoflurane Fentanyl/fluanisone"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Ketamine"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Ketamine Halothane"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Ketamine Medetomidine"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="MS-222"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Nitrous oxide Enflurane"] <- "Other"
#levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="None"] <- "Other" 
#careful, this line has been changing #comorbidity's "none" to "other" as well - there are 6 "None" anaesthetics, change them in dfc3_Barplot_methods creation in original anaesthetics variable so we don't have this issue.
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Tiletamine-Zolazepam Xylazine"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Urethane"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Zoletil Tiletamine-Zolazepam"] <- "Other"

summary(dfc3_Barplot_methods$Methods_value)

#light source factors to "other" (only for ease of visibility on this barplot, not for meta-analysis)
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Metal-halide"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Mercury"] <- "Other"
levels(dfc3_Barplot_methods$Methods_value)[levels(dfc3_Barplot_methods$Methods_value)=="Argon laser"] <- "Other"



#order the factors
dfc3_Barplot_methods$Methods_variable <- factor(dfc3_Barplot_methods$Methods_variable, levels = c("Anaesthetic", "RB_dose_mgkg_cat", "Light_source", "Light_aperture_cat", "Light_time_cat", "Light_wavelength_cat", "Light_intensity_cat"))
#order of values
dfc3_Barplot_methods$Methods_value <- factor(dfc3_Barplot_methods$Methods_value, 
                                             levels = c("Not reported", 
                                                        "Isoflurane", "Nitrous oxide Halothane", "Halothane", "Ketamine Xylazine", "Chloral hydrate", "Nitrous oxide Isoflurane", "Sodium Pentobarbital", 
                                                        '0.1-15mg/kg', '15-30mg/kg', '30-45mg/kg', '45-60mg/kg', '60-75mg/kg', '75+mg/kg', 
                                                        "Xenon", "Cold light (unspecified)", "Green laser (unspecified)", "Halogen", "Diode laser (unspecified)", "Krypton laser", "LED",
                                                        '0.02-1mm', '1-2mm', '2-3mm', '3-4mm', '4-5mm', '5+mm', 
                                                        "0.5-5mins", "5-10mins", "10-15mins", "15-20mins",  "20+mins", 
                                                        "450-500nm", "500-550nm", "550-600nm", "600+nm", 
                                                        '0.0002-0.5 W/cm^2', '0.5-1 W/cm^2', '1-10 W/cm^2', '10+ W/cm^2', 
                                                        "Other"))

```

```{r Stacked_barplots_graph_2, include=FALSE, eval=FALSE}
#Barplot on methods variables
pdf("Study_Methods_variables_barplot_5.pdf", height=5.5, width=7.5)
ggplot(dfc3_Barplot_methods, aes(fill=Methods_value, x=Methods_variable)) + 
  geom_bar(alpha = 0.8) +
  theme_bw() +
  scale_fill_manual(values = c("Not reported"= plasma(3)[1], 
                     "Isoflurane" = plasma(9)[2], "Nitrous oxide Halothane"= plasma(9)[3], "Halothane"= plasma(9)[4], "Ketamine Xylazine"= plasma(9)[5], "Chloral hydrate"= plasma(9)[6], "Nitrous oxide Isoflurane"= plasma(9)[7], "Sodium Pentobarbital"= plasma(9)[8], "Other"= plasma(9)[9],
                    "0.1-15mg/kg"= plasma(8)[2], "15-30mg/kg"= plasma(8)[3], "30-45mg/kg"= plasma(8)[4], "45-60mg/kg"= plasma(8)[5], "60-75mg/kg"= plasma(8)[6], "75+mg/kg"= plasma(8)[7], 
                    "Xenon"= plasma(9)[2], "Cold light (unspecified)"= plasma(9)[3], "Green laser (unspecified)"= plasma(9)[4], "Halogen"= plasma(9)[5],"Diode laser (unspecified)"= plasma(9)[6], "Krypton laser"= plasma(9)[7], "LED"= plasma(9)[8], 
                    "0.02-1mm"= plasma(8)[2], "1-2mm"= plasma(8)[3], "2-3mm"= plasma(8)[4], "3-4mm"= plasma(8)[5], "4-5mm"= plasma(8)[6], "5+mm"= plasma(8)[7], 
                    "0.5-5mins"= plasma(7)[2], "5-10mins"= plasma(7)[3], "10-15mins"= plasma(7)[4], "15-20mins"= plasma(7)[5],  "20+mins"= plasma(7)[6],
                    "450-500nm"= plasma(6)[2], "500-550nm"= plasma(6)[3], "550-600nm"= plasma(6)[4], "600+nm"= plasma(6)[5],
                    "0.0002-0.5 W/cm^2"= plasma(6)[2], "0.5-1 W/cm^2"= plasma(6)[3], "1-10 W/cm^2"= plasma(6)[4], "10+ W/cm^2"= plasma(6)[5])) +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black")) +
  geom_text(aes(label=Methods_value), stat="count", position = "stack", vjust=1.2) +
  labs(y="Number of experiments", x= "") +
  scale_x_discrete(labels = c("Anaesthetic", "Rose Bengal Dose", "Light Source", "Light Aperture", "Light Exposure Time", "Light Wavelength", "Light Intensity")) +
  ylim(-15,440)
dev.off()

```


# Dataframes needed for models

```{r Dataframe_for_models_variable_editing, include=FALSE}
#this dataframe has base variables edited to change NA's into NR's, and to put factors with small numbers of instances into groups of "other"
dfc3_Models <- dfc3_Unique

#any group with fewer than 8 instances (double the last analysis as we have double the experiments) are changed to "other"
#changing Animal
summary(dfc3_Unique$Animal)
levels(dfc3_Models$Animal) <- c(levels(dfc3_Models$Animal), "Other") #add "other" as a level
dfc3_Models$Animal[dfc3_Models$Animal=="Guinea Pig"] <- "Other"
dfc3_Models$Animal[dfc3_Models$Animal=="Primate"] <- "Other"
dfc3_Models$Animal[dfc3_Models$Animal=="Rabbit"] <- "Other"
dfc3_Models$Animal[dfc3_Models$Animal=="Zebrafish"] <- "Other"
dfc3_Models$Animal <- droplevels(dfc3_Models$Animal) #drop empty levels created above
summary(dfc3_Models$Animal) #check it is all correct and "other" has >= 8 instances now

summary(dfc3_Unique$Sex) # change NR
levels(dfc3_Models$Sex) <- c(levels(dfc3_Models$Sex), "Not reported") #add "Not reported" as a level
dfc3_Models$Sex[dfc3_Models$Sex=="NR"] <- "Not reported"
dfc3_Models$Sex <- droplevels(dfc3_Models$Sex) #drop empty levels created above
summary(dfc3_Models$Sex)

summary(dfc3_Unique$Infarct_time) #no issues, numeric with only 16 NAs

summary(dfc3_Unique$Infarct_measurement) #NR has 7 instances, below min but keeping all NRs
levels(dfc3_Models$Infarct_measurement) <- c(levels(dfc3_Models$Infarct_measurement), "Not reported") #add "Not reported" as a level
dfc3_Models$Infarct_measurement[dfc3_Models$Infarct_measurement=="NR"] <- "Not reported"
dfc3_Models$Infarct_measurement <- droplevels(dfc3_Models$Infarct_measurement) #drop empty levels created above
summary(dfc3_Models$Infarct_measurement)

#changing surgical severity
summary(dfc3_Unique$Surgical_level) #note 4 NR's, below min but keeping all NRs
levels(dfc3_Models$Surgical_level) <- c(levels(dfc3_Models$Surgical_level), "Not reported") #add "Not reported" as a level
dfc3_Models$Surgical_level[dfc3_Models$Surgical_level=="Cranial window (asleep induction)"] <- "Other"
dfc3_Models$Surgical_level[dfc3_Models$Surgical_level=="Cranial window (awake induction)"] <- "Other"
dfc3_Models$Surgical_level[dfc3_Models$Surgical_level=="Scalp and skull intact"] <- "Other"
dfc3_Models$Surgical_level[dfc3_Models$Surgical_level=="NR"] <- "Not reported"
dfc3_Models$Surgical_level <- droplevels(dfc3_Models$Surgical_level) #drop empty levels created above
summary(dfc3_Models$Surgical_level) #other now has 24 instances

#changing comorbidity
summary(dfc3_Unique$Comorbidity)
levels(dfc3_Models$Comorbidity) <- c(levels(dfc3_Models$Comorbidity), "Other") #add "other" as a level
dfc3_Models$Comorbidity[dfc3_Models$Comorbidity=="Amyloid plaques"] <- "Other"
dfc3_Models$Comorbidity[dfc3_Models$Comorbidity=="Chronic colitis"] <- "Other"
dfc3_Models$Comorbidity[dfc3_Models$Comorbidity=="Diabetes"] <- "Other"
dfc3_Models$Comorbidity[dfc3_Models$Comorbidity=="Hyperglycemia"] <- "Other"
dfc3_Models$Comorbidity[dfc3_Models$Comorbidity=="Immunodeficiency"] <- "Other"
dfc3_Models$Comorbidity[dfc3_Models$Comorbidity=="Lupus"] <- "Other"
dfc3_Models$Comorbidity[dfc3_Models$Comorbidity=="Obesity"] <- "Other"
dfc3_Models$Comorbidity <- droplevels(dfc3_Models$Comorbidity) #drop empty levels created above
summary(dfc3_Models$Comorbidity) #Other now has 11 instances

#no need to check dummy anaesthetic variables

summary(dfc3_Unique$RB_dose_mgkg_cat) #56 NA's - change to NR's
levels(dfc3_Models$RB_dose_mgkg_cat) <- c(levels(dfc3_Models$RB_dose_mgkg_cat), "Not reported") #add "Not reported" as a level
dfc3_Models$RB_dose_mgkg_cat[is.na(dfc3_Models$RB_dose_mgkg_cat)] <- "Not reported" #change NA's to NR's
summary(dfc3_Models$RB_dose_mgkg_cat) #may still need to change 120-150mg/kg factor

summary(dfc3_Unique$Light_intensity_cat) #335 NA's, change to NR's
levels(dfc3_Models$Light_intensity_cat) <- c(levels(dfc3_Models$Light_intensity_cat), "Not reported") #add "Not reported" as a level
dfc3_Models$Light_intensity_cat[is.na(dfc3_Models$Light_intensity_cat)] <- "Not reported" #change NA's to NR's
summary(dfc3_Models$Light_intensity_cat) #may still need to change: 1-10 W/cm^2 10+ W/cm^2 as these have between 8 and 6 instances each

summary(dfc3_Unique$Light_source)
levels(dfc3_Models$Light_source) <- c(levels(dfc3_Models$Light_source), "Not reported") #add "Not reported" as a level
dfc3_Models$Light_source[dfc3_Models$Light_source=="Argon laser"] <- "Other"
dfc3_Models$Light_source[dfc3_Models$Light_source=="Mercury"] <- "Other"
dfc3_Models$Light_source[dfc3_Models$Light_source=="Metal-halide"] <- "Other"
dfc3_Models$Light_source[dfc3_Models$Light_source=="NR"] <- "Not reported"
dfc3_Models$Light_source <- droplevels(dfc3_Models$Light_source) #drop empty levels created above
summary(dfc3_Models$Light_source) #other now has 26 instances

summary(dfc3_Unique$Light_aperture_cat) #NA's 117
levels(dfc3_Models$Light_aperture_cat) <- c(levels(dfc3_Models$Light_aperture_cat), "Not reported") #add "Not reported" as a level
dfc3_Models$Light_aperture_cat[is.na(dfc3_Models$Light_aperture_cat)] <- "Not reported" #change NA's to NR's
summary(dfc3_Models$Light_aperture_cat) #all good now

summary(dfc3_Unique$Light_wavelength_cat) #both 450-500nm and 600+nm have <8 instances, how to deal? 117 NA's
levels(dfc3_Models$Light_wavelength_cat) <- c(levels(dfc3_Models$Light_wavelength_cat), "Not reported") #add "Not reported" as a level
dfc3_Models$Light_wavelength_cat[is.na(dfc3_Models$Light_wavelength_cat)] <- "Not reported" #change NA's to NR's
summary(dfc3_Models$Light_wavelength_cat) #may still need to change 450-500nm and 600+nm

summary(dfc3_Unique$Light_time) #numeric variable with 15 NA's, should be fine
#checking categorical version
summary(dfc3_Unique$Light_time_cat)
levels(dfc3_Models$Light_time_cat) <- c(levels(dfc3_Models$Light_time_cat), "Not reported") #add "Not reported" as a level
dfc3_Models$Light_time_cat[is.na(dfc3_Models$Light_time_cat)] <- "Not reported" #change NA's to NR's
summary(dfc3_Models$Light_time_cat) #all good now

```

```{r Dataframe_for_models_factor_levels, include=FALSE}
#changing the baseline of each variable to be the factor with most n (or ordering them in a logical manner)

summary(dfc3_Models$Animal)
dfc3_Models$Animal <- factor(dfc3_Models$Animal, levels = c('Rat','Mouse','Other'))
summary(dfc3_Models$Animal)

summary(dfc3_Models$Sex)
dfc3_Models$Sex <- factor(dfc3_Models$Sex, levels = c('Male','Female','Mixed', 'Not reported'))
summary(dfc3_Models$Sex)

summary(dfc3_Models$Infarct_measurement)
dfc3_Models$Infarct_measurement <- factor(dfc3_Models$Infarct_measurement, 
                                          levels = c('Other histology (ex vivo)',
                                                     'TTC (ex vivo)',
                                                     'MRI (in vivo)', 
                                                     'Not reported'))
summary(dfc3_Models$Infarct_measurement)

summary(dfc3_Models$Surgical_level) 
dfc3_Models$Surgical_level <- factor(dfc3_Models$Surgical_level, 
                                          levels = c('Scalp retracted, skull intact',
                                                     'Skull thinned',
                                                     'Skull breached',
                                                     'Other',
                                                     'Not reported'))
summary(dfc3_Models$Surgical_level)

summary(dfc3_Models$Comorbidity)
dfc3_Models$Comorbidity <- factor(dfc3_Models$Comorbidity, 
                                  levels = c('None','Hypertension','Aged', 'Other'))
summary(dfc3_Models$Comorbidity)


summary(dfc3_Models$RB_dose_mgkg_cat) #leaving as it's a logical order (low to high)

summary(dfc3_Models$Light_intensity_cat) #leaving as it's a logical order (low to high)

summary(dfc3_Models$Light_source)
dfc3_Models$Light_source <- factor(dfc3_Models$Light_source, 
                                          levels = c('Xenon',
                                                     'Cold light (unspecified)',
                                                     'Green laser (unspecified)',
                                                     'Halogen',
                                                     'Diode laser (unspecified)',
                                                     'Krypton laser',
                                                     'LED',
                                                     'Other',
                                                     'Not reported'))
summary(dfc3_Models$Light_source)

summary(dfc3_Models$Light_aperture_cat) #leaving as it's a logical order (low to high)


summary(dfc3_Models$Light_wavelength_cat) #although it's a logical order, only 2 instances of 450-500nm, so changing to be based on n instead
dfc3_Models$Light_wavelength_cat <- factor(dfc3_Models$Light_wavelength_cat,
                                          levels = c('500-550nm',
                                                     '550-600nm',
                                                     '600+nm',
                                                     '450-500nm',
                                                     'Not reported'))
summary(dfc3_Models$Light_wavelength_cat)

summary(dfc3_Models$Light_time_cat) #leaving as it's a logical order (low to high)


```

```{r Dataframe_summary_tables, include=FALSE}

summary(dfc3_Unique$Light_source)

#make dataframe for summary tables
dfc3_summary_tables <- dfc3_Models #428 experiments
#remove "other" species
dfc3_summary_tables <- droplevels(dfc3_summary_tables[!dfc3_summary_tables$Animal == "Other", ]) #418 experiements in rats/mice
# remove "not reported" surgical level
dfc3_summary_tables <- droplevels(dfc3_summary_tables[!dfc3_summary_tables$Surgical_level == "Not reported", ]) #414 reported surgery
#check how many unique studies this includes
dfc3_summary_tables$Publication_code <- as.factor(dfc3_summary_tables$Publication_code) #make a factor
dfc3_summary_tables$Publication_code <- droplevels(dfc3_summary_tables$Publication_code) #drop empty levels that may have accidentally been created previouslt
nlevels(as.factor(dfc3_summary_tables$Publication_code)) #check number of levels to see n of unique studies

# Create group for rats only
dfc3_summary_tables_rat <- droplevels(dfc3_summary_tables[!dfc3_summary_tables$Animal == "Mouse", ])
  
# Create group for mice only
dfc3_summary_tables_mouse <- droplevels(dfc3_summary_tables[!dfc3_summary_tables$Animal == "Rat", ])

#summaries by rat/mouse (swap out variables as needed)
summary(dfc3_summary_tables_rat$Light_source)
summary(dfc3_summary_tables_mouse$Light_source)

#summary tables by surgical level (swap out first variable as needed)
table(dfc3_summary_tables_rat$Light_aperture_cat, dfc3_summary_tables_rat$Surgical_level) #rat
table(dfc3_summary_tables_mouse$Light_aperture_cat, dfc3_summary_tables_mouse$Surgical_level) #mouse

#summary for continuous variables (swap out first variable as needed)
#rat
tapply(dfc3_summary_tables_rat$Infarct_time, dfc3_summary_tables_rat$Surgical_level, mean, na.rm=TRUE) #mean
tapply(dfc3_summary_tables_rat$Infarct_time, dfc3_summary_tables_rat$Surgical_level, sd, na.rm=TRUE) #standard deviation
#mouse
tapply(dfc3_summary_tables_mouse$Infarct_time, dfc3_summary_tables_mouse$Surgical_level, mean, na.rm=TRUE) #mean
tapply(dfc3_summary_tables_mouse$Infarct_time, dfc3_summary_tables_mouse$Surgical_level, sd, na.rm=TRUE) #standard deviation

#summary for modal table - most common methods by rats and mice (swap out first variable as needed)
summary(dfc3_summary_tables_rat$Infarct_measurement)[which.max(summary(dfc3_summary_tables_rat$Infarct_measurement))] #rat
summary(dfc3_summary_tables_mouse$Infarct_measurement)[which.max(summary(dfc3_summary_tables_mouse$Infarct_measurement))] #mouse

summary(as.factor(dfc3_summary_tables_mouse$Infarct_time))

```

```{r Dataframe_for_models_remove_small_factors, include=FALSE}
#removing any factors that are causing rank-deficiencies in our model (ie not enough of them to make predictions)

#"not reported" in surgical level
dfc3_Models <- dfc3_Models %>%
  filter(is.na(Surgical_level) | #need this line of code or it filters out all rows with NAs
           Surgical_level != "Not reported")
dfc3_Models$Surgical_level <- droplevels(dfc3_Models$Surgical_level) #drop empty levels created above
summary(dfc3_Models$Surgical_level)

#"not reported" in infarct measurement
dfc3_Models <- dfc3_Models %>%
  filter(is.na(Infarct_measurement) | #need this line of code or it filters out all rows with NAs
           Infarct_measurement != "Not reported")
dfc3_Models$Infarct_measurement <- droplevels(dfc3_Models$Infarct_measurement) #drop empty levels created above
summary(dfc3_Models$Infarct_measurement)

```


#Collinearity testing

```{r Variable_creation_collinearity_plots, include=FALSE, eval=FALSE}
#new dataframe for collinearity plots
dfc3_coll <- dfc3_Models

# Dummy variable for surgical level
for(i in levels(dfc3_coll$Surgical_level)){
dfc3_coll$newcol<-0
dfc3_coll$newcol <-(dfc3_coll$Surgical_level==i)*1 
dfc3_coll [is.na(dfc3_coll$newcol)]<-0 
colnames(dfc3_coll)[ncol(dfc3_coll)]<-i
}
colnames(dfc3_coll)[colnames(dfc3_coll)=="Other"]<-"Other_surgical"

# Dummy variable for light source
for(i in levels(dfc3_coll$Light_source)){
dfc3_coll$newcol<-0
dfc3_coll$newcol <-(dfc3_coll$Light_source==i)*1 
dfc3_coll$newcol [is.na(dfc3_coll$newcol)]<-0 
colnames(dfc3_coll)[ncol(dfc3_coll)]<-i
}
colnames(dfc3_coll)[colnames(dfc3_coll)=="Not reported"]<-"Not_reported_light_source"
colnames(dfc3_coll)[colnames(dfc3_coll)=="Other"]<-"Other_light_source"

# Dummy variable for Treatment Time Class
for(i in levels(dfc3_coll$Infarct_measurement)){
dfc3_coll$newcol<-0
dfc3_coll$newcol <-(dfc3_coll$Infarct_measurement==i)*1 
dfc3_coll$newcol[is.na(dfc3_coll$newcol)]<-0 
colnames(dfc3_coll)[ncol(dfc3_coll)]<-i
}

# Animal dummy variables
for(i in levels(dfc3_coll$Animal)){
dfc3_coll$newcol<-0
dfc3_coll$newcol <-(dfc3_coll$Animal==i)*1 
dfc3_coll$newcol[is.na(dfc3_coll$newcol)]<-0 
colnames(dfc3_coll)[ncol(dfc3_coll)]<-i
}
colnames(dfc3_coll)[colnames(dfc3_coll)=="Other"]<-"Other_animals"

# Sex dummy variables
for(i in levels(dfc3_coll$Sex)){
dfc3_coll$newcol<-0
dfc3_coll$newcol <-(dfc3_coll$Sex==i)*1 
dfc3_coll$newcol[is.na(dfc3_coll$newcol)]<-0 
colnames(dfc3_coll)[ncol(dfc3_coll)]<-i
}
colnames(dfc3_coll)[colnames(dfc3_coll)=="Not reported"]<-"Sex not reported"

# Comorbidity dummy variables
for(i in levels(dfc3_coll$Comorbidity)){
dfc3_coll$newcol<-0
dfc3_coll$newcol <-(dfc3_coll$Comorbidity==i)*1 
dfc3_coll$newcol[is.na(dfc3_coll$newcol)]<-0 
colnames(dfc3_coll)[ncol(dfc3_coll)]<-i
}
colnames(dfc3_coll)[colnames(dfc3_coll)=="None"]<-"No comorbidity"
colnames(dfc3_coll)[colnames(dfc3_coll)=="Other"]<-"Other comorbidity"


```

```{r Collinearity plot, include=FALSE, eval=FALSE}
#list all the variables of interest for collinearity checking
column_interest <- c("Infarct_percent_control",
                     "Isoflurane",
                     "Ketamine",
                     "Xylazine",
                     "Nitrous_oxide",
                     "Halothane",
                     "Chloral_hydrate",
                     "Sodium_pentobarbital",
                     "Enflurane",
                     "Tiletamine_Zolazepam",
                     "Anaesthetic_not_reported",
                     "Other_anaesthetics",
                     "Scalp retracted, skull intact",
                     "Skull thinned",
                     "Skull breached",
                     "Other_surgical",
                     "Light_aperture", 
                     "Light_time",
                     'Xenon',
                     'Cold light (unspecified)',
                     'Green laser (unspecified)',
                     'Halogen',
                     'Diode laser (unspecified)',
                     'Krypton laser',
                     'LED',
                     "Other_light_source",
                     "Not_reported_light_source",
                     "Infarct_time",
                     "Other histology (ex vivo)",
                     "TTC (ex vivo)",
                     "MRI (in vivo)",
                     "Rat",
                     "Mouse",
                     "Other_animals",
                     "RB_dose_mgkg",
                     "Male",
                     "Female",
                     "Mixed",
                     "Sex not reported",
                     "No comorbidity",
                     "Aged",
                     "Hypertension",
                     "Other comorbidity")
#select just these columns from the dataframe
matrix_coll<-subset(dfc3_coll, select = column_interest)
#how many NA's there are
for(i in 1:ncol(matrix_coll)){
  print(column_interest[i])
print(sum(is.na(matrix_coll[,i])))
}
#remove NA's, complete cases only
matrix_coll<-matrix_coll[complete.cases(matrix_coll),]
mat<-as.matrix(matrix_coll) #turn into a matrix

#make the corrplot
pdf("Collinearity_corrplot_3.pdf", heigh=20, width=20)
corr_matrix<-cor(mat) 
testRes = cor.mtest(mat, conf.level = 0.95)
corrplot(corr_matrix, p.mat = testRes$p, method = 'circle', type = 'lower', insig='blank',
         addCoef.col ='black', number.cex = 0.8, diag=FALSE,tl.col="black")

corrplot(corr_matrix, method = 'circle', type = 'lower', number.cex = 0.8, diag=FALSE, tl.col="black")
dev.off

```


# Model testing
To select optimal model, I test several lm/glm options to make sure the data best fits the model's assumptions and we include as many appropriate variables and interactions as possible. All of these are kept in the code as evidence of testing, only lm_clean and lm_clean_transformed in the "" section are needed for the code.
```{r Model_attempt_1, evaluate=FALSE, include=FALSE}
#might need to use a glm using the beta family (lm assumes normal dist, glm assumes otherwise), beta distribution only lets data sit between o and 1, and we may use percents. If mean is somewhere in middle it will approximate a normal distribution

#this is type 1, order does matter - put nuisance variables first (note it will always put interaction terms last)

lm_initial <- lm(data = dfc3_Unique,
   Infarct_percent_control ~
     Animal +
     Sex +
     Infarct_time +
     Infarct_measurement +
     Infarct_measurement*Surgical_level +
     Surgical_level +
     Comorbidity +
     Anaesthetic +#need to dummy variable 
     RB_dose_mgkg +
     Light_intensity_cat + 
     Light_source +
     Light_aperture_cat +
     Light_wavelength_cat + #may be waste of time
     Light_time +
     Light_time*Surgical_level,
   weights = N_animals_control
   )

summary(lm_initial)

tab_model(lm_initial)

tab_df(anova(lm_initial), show.rownames = TRUE)
```

```{r Model_attempt_2, evaluate=FALSE, include=FALSE}
#might need to use a glm using the beta family (lm assumes normal dist, glm assumes otherwise), beta distribution only lets data sit between o and 1, and we may use percents. If mean is somewhere in middle it will approximate a normal distribution

#this is type 1, order does matter - put nuisance variables first (note it will always put interaction terms last)

lm_second <- lm(data = dfc3_Models,
   Infarct_percent_control ~
     Animal +
     Sex +
     Infarct_time + #this is numeric with 16 NA's
     Infarct_measurement +
     Infarct_measurement*Surgical_level +
     Surgical_level +
     Comorbidity +
     #Anaesthetic +#need to dummy variable 
     Isoflurane + #dummy
     Ketamine + #dummy
     Xylazine + #dummy
     Nitrous_oxide + #dummy
     Halothane + #dummy
     Chloral_hydrate + #dummy
     Sodium_pentobarbital + #dummy
     Enflurane + #dummy
     Tiletamine_Zolazepam + #dummy
     Anaesthetic_not_reported + #dummy
     Other_anaesthetics +
     RB_dose_mgkg_cat + #56 NA's in numeric, using categorical instead
     Light_intensity_cat + #may remove, groups too small for predictions
     Light_source +
     Light_aperture_cat +
     Light_wavelength_cat + #may remove, groups too small for predictions
     Light_time_cat,#numeric with 15 NA's, changed to categorical
     #Light_time_cat*Surgical_level, #removed due to too many rank-deficiencies
   weights = N_animals_control
   )

summary(lm_second)

tab_model(lm_second)

tab_df(anova(lm_second), show.rownames = TRUE)
```

```{r Model_testing_glm, evaluate=FALSE, include=FALSE}
#first possible model - beta distribution glm - testing this as a possible model

#using a glm as data appears to fit a beta distribution (lm assumes normal dist, glm assumes otherwise), beta distribution only lets data sit between 0 and 1, and we may use percents. If mean is somewhere in middle it will approximate a normal distribution

#convert Infarct_percent_control to sit between 0 and 1
summary(dfc3_Models$Infarct_percent_control)
dfc3_Models$Infarct_beta<-dfc3_Models$Infarct_percent_control/100

#run glm model using beta regression
glm_full <- betareg(data = dfc3_Models,
   Infarct_beta ~
     Animal +
     Sex +
     Infarct_time + #this is numeric with 16 NA's
     Infarct_measurement +
     Infarct_measurement*Surgical_level + #interaction
     Surgical_level +
     Comorbidity +
     Isoflurane + #dummy
     Ketamine + #dummy
     Xylazine + #dummy
     Nitrous_oxide + #dummy
     Halothane + #dummy
     Chloral_hydrate + #dummy
     Sodium_pentobarbital + #dummy
     Enflurane + #dummy
     Tiletamine_Zolazepam + #dummy
     Anaesthetic_not_reported + #dummy
     Other_anaesthetics +
     RB_dose_mgkg_cat + #56 NA's in numeric, using categorical instead
     # Light_intensity_cat + #may remove, groups too small for predictions
     Light_source +
     Light_aperture_cat +
     # Light_wavelength_cat + #may remove, groups too small for predictions
     Light_time_cat,#numeric with 15 NA's, changed to categorical
   weights = N_animals_control
   )

summary(glm_full) #this is type 3 - order doesn't matter

tab_model(glm_full)

#tab_df(anova(glm_full), show.rownames = TRUE) #this line won't work for a glm

plot(glm_full) #some diagnostic plots. Annoyingly it won't plot q-q plots, but Jack had a look at that one manually

#after assessing fit of beta distribution model vs a transformed model (making the data fit a normal distribution) we decided to use the lm transformed model. Both fit well, but the lm is technically simpler and we have a wider range of tools we can use with an lm. Also the lm appears to be outputting a much more conservative estimate of variable significance, and has a higher R^2 so may explain the data better
```



Outlier detection
```{r Model_lm_checking, evaluate=FALSE, include=FALSE}
#selected model: transformed linear model - now check for outliers etc

#linear model with all cleaned variables
lm_full <- lm(data = dfc3_Models,
   Infarct_percent_control ~
     Animal +
     Sex +
     Infarct_time + #this is numeric with 16 NA's
     Infarct_measurement +
     Infarct_measurement*Surgical_level + #interaction
     Surgical_level +
     Comorbidity +
     Isoflurane + #dummy
     Ketamine + #dummy
     Xylazine + #dummy
     Nitrous_oxide + #dummy
     Halothane + #dummy
     Chloral_hydrate + #dummy
     Sodium_pentobarbital + #dummy
     Enflurane + #dummy
     Tiletamine_Zolazepam + #dummy
     Anaesthetic_not_reported + #dummy
     Other_anaesthetics +
     RB_dose_mgkg_cat + #56 NA's in numeric, using categorical instead
     # Light_intensity_cat + #removed, groups too small for predictions, mostly NR
     Light_source +
     Light_aperture_cat +
     # Light_wavelength_cat + #removed, groups too small for predictions, mostly NR
     Light_time_cat,#numeric with 15 NA's, changed to categorical
   weights = N_animals_control
   )

#BoxCox transformation of this model
lm_boxcox<-boxcox(lm_full,lambda = seq(-5, 5, 1/1000), plotit = TRUE)

Selected.lambda <-lm_boxcox$x[lm_boxcox$y==max(lm_boxcox$y)] 
Selected.lambda 

#Run the transformed model
lm_full_transformed <- lm(data = dfc3_Models,
   Infarct_percent_control^Selected.lambda  ~ #transformed dependent variable
     Animal +
     Sex +
     Infarct_time + #this is numeric with 16 NA's
     Infarct_measurement +
     Infarct_measurement*Surgical_level + #interaction
     Surgical_level +
     Comorbidity +
     Isoflurane + #dummy
     Ketamine + #dummy
     Xylazine + #dummy
     Nitrous_oxide + #dummy
     Halothane + #dummy
     Chloral_hydrate + #dummy
     Sodium_pentobarbital + #dummy
     Enflurane + #dummy
     Tiletamine_Zolazepam + #dummy
     Anaesthetic_not_reported + #dummy
     Other_anaesthetics +
     RB_dose_mgkg_cat + #56 NA's in numeric, using categorical instead
     # Light_intensity_cat + #removed, groups too small for predictions, mostly NR
     Light_source +
     Light_aperture_cat +
     # Light_wavelength_cat + #removed, groups too small for predictions, mostly NR
     Light_time_cat,#numeric with 15 NA's, changed to categorical
   weights = N_animals_control
   )

summary(lm_full_transformed) #this is type 3 - order doesn't matter

tab_model(lm_full_transformed)

#tab_df(anova(lm_full_transformed), show.rownames = TRUE) #this is type 1 - order matters 
tab_df(car::Anova(lm_full_transformed), show.rownames = TRUE, digits=4) #this is type 3 - order doesn't matter. Use this

#diagnostic plots
autoplot(lm_full,which = c(1,2,4))
autoplot(lm_full_transformed,which = c(1,2,4))

#Outlier detection
olsrr::ols_plot_dffits(lm_full_transformed) # removing each study one at a time and seeing if it changes the regression, it chooses a threshold but it is arbitrary
olsrr::ols_plot_cooksd_chart(lm_full_transformed) # cooks distance chart (note it is different to other identified cooks distance outliers, so use the autoplot one)
olsrr::ols_plot_hadi(lm_full_transformed) # is it the dependent variable's or the independent variable's fault for it being an outlier, higher the value, the more it is the explanatory variables

#looking at all of the above, row number 7 is the only one scoring highly across all diagnostic cases

```

Deciding if beta regression or ols methods are better
```{r Model_selection, evaluate=FALSE, include=FALSE}

plot(glm_full) #diagnostic plots
as.numeric(names(which(cooks.distance(glm_full)>2))) #which rows have a high cook's distance

dfc3_Models[as.numeric(names(which(cooks.distance(glm_full)>2))),] #which rows have a high cook's distance, using these numbers to print the rows
fit_beta<-fitdistrplus::fitdist(dfc3_Models$Infarct_beta, "beta") # model the infarct beta with a beta distribution

qbeta<-rbeta(10000,fit_beta$estimate[1],fit_beta$estimate[2]) # generate the hypothetical data if our dependent variable followed a beta distribution

# plot the hypothetical data vs our actual data, hypothetical in blue, actual in red (beta dist)
plot(ecdf(qbeta),col="blue", cex=3, lwd=5, main ="CDF of a beta distribution") 
lines(ecdf(dfc3_Models$Infarct_beta), col="red")
legend("bottomright", c("Data (red)","Predicted (blue)"), col=c("red","blue"), lty=1)

fit_norm <- fitdist(dfc3_Models$Infarct_percent_control^Selected.lambda, "norm") # model the infarct percent with a normal dist
qnorm<-rnorm(10000,mean=fit_norm$estimate[1], sd=fit_norm$estimate[2]) # make theoretical normal distribution

# plot the hypothetical data vs our actual data, hypothetical in blue, actual in red (normal dist)
plot(ecdf(qnorm),col="blue", cex=3, lwd=5,  main ="CDF of a normal distribution after transformation")
lines(ecdf(dfc3_Models$Infarct_percent_control^Selected.lambda), col="red")
legend("bottomright", c("Data (red)","Predicted (blue)"), col=c("red","blue"), lty=1)

```


# Final model selection
Final_Model_final_v2_FINAL_complete_v3
```{r Model_full_lm, warning=FALSE}
#removing study #7 as only identified major outlier

dfc3_Models_clean <- dfc3_Models[-7,]

#linear model with all cleaned variables + one outlier removed
lm_clean <- lm(data = dfc3_Models_clean,
   Infarct_percent_control ~
     Animal +
     Sex +
     Infarct_time + #this is numeric with 12 NA's
     Infarct_measurement +
     Infarct_measurement*Surgical_level + #interaction
     Surgical_level +
     Comorbidity +
     Isoflurane + #dummy
     Ketamine + #dummy
     Xylazine + #dummy
     Nitrous_oxide + #dummy
     Halothane + #dummy
     Chloral_hydrate + #dummy
     Sodium_pentobarbital + #dummy
     Enflurane + #dummy
     Tiletamine_Zolazepam + #dummy
     Anaesthetic_not_reported + #dummy
     Other_anaesthetics + #dummy
     RB_dose_mgkg_cat + #54 NA's in numeric, using categorical instead
     Light_source +
     Light_aperture_cat + #numeric with 111 NA's, changed to categorical
     Light_time_cat,#numeric with 12 NA's, changed to categorical
   weights = N_animals_control
   )

#BoxCox transformation of this model
lm_boxcox<-boxcox(lm_clean,lambda = seq(-5, 5, 1/1000), plotit = TRUE)

Selected.lambda_clean <-lm_boxcox$x[lm_boxcox$y==max(lm_boxcox$y)] 
Selected.lambda_clean

#Run the transformed model
lm_clean_transformed <- lm(data = dfc3_Models_clean,
   Infarct_percent_control^Selected.lambda_clean  ~ #transformed dependent variable
     Animal +
     Sex +
     Infarct_time + #this is numeric with 16 NA's
     Infarct_measurement +
     Infarct_measurement*Surgical_level + #interaction
     Surgical_level +
     Comorbidity +
     Isoflurane + #dummy
     Ketamine + #dummy
     Xylazine + #dummy
     Nitrous_oxide + #dummy
     Halothane + #dummy
     Chloral_hydrate + #dummy
     Sodium_pentobarbital + #dummy
     Enflurane + #dummy
     Tiletamine_Zolazepam + #dummy
     Anaesthetic_not_reported + #dummy
     Other_anaesthetics +
     RB_dose_mgkg_cat + #56 NA's in numeric, using categorical instead
     Light_source +
     Light_aperture_cat +
     Light_time_cat,#numeric with 15 NA's, changed to categorical
   weights = N_animals_control
   )

summary(lm_clean_transformed) #this is type 3 - order doesn't matter

tab_model(lm_clean_transformed, 
          file="lm_main_model_full_2.html")

tab_df(car::Anova(lm_clean_transformed), show.rownames = TRUE, digits=4,
       file="lm_main_model_ANOVA_2.html") #this is type 3 - order doesn't matter.

```

```{r Model_outcome_variable_check, eval=False, include=FALSE}
#quick test to check if body weight or age is affecting predicted brain volume, i.e. are brains bigger in larger or older animals?
#if yes, this outcome variable is not particularly reliable

lm_weight_test <- lm(data = dfc3_Models_clean,
                     Infarct_percent_control^Selected.lambda_clean  ~
                       Weight_g_mean +
                       Age_weeks_mean,
                     weights = N_animals_control
   )

summary(lm_weight_test)
car::Anova(lm_weight_test)

#neither predictor variable is significant, seems infarct volume not predicted by animal's age or weight

```



#Creating predicted value figures

```{r Dataframes_predicted_animal_sex_comorbidity, include=FALSE}
# Figure 2 is predicted value plot with Animal, Sex, Comorbidity, and Measurement*Surgical level

#create predicted values for each variable and un-transform them so they are in % change in infarct volume
levels(dfc3_Models_clean$RB_dose_mgkg_cat)
#Animal
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Animal<-expand.grid(Animal = levels(dfc3_Models_clean$Animal),
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     Enflurane =0, #dummy
     Tiletamine_Zolazepam =0, #dummy
     Anaesthetic_not_reported =0, #dummy
     Other_anaesthetics =0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Animal_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Animal)
# generate lower confidence intervals by subtracting standard errors
Animal_LCI_untransformed <- Animal_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Animal, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Animal_UCI_untransformed<-Animal_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Animal, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Animal_predicted <- data.frame(grid_Animal$Animal, Animal_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Animal_LCI_untransformed^(1/Selected.lambda_clean),
                                  Animal_UCI_untransformed^(1/Selected.lambda_clean))

# Change the column names
colnames(df_Animal_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
Animal.correct<- df_Animal_predicted[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Animal_predicted$Infarct_volume<-df_Animal_predicted$Infarct_volume-Animal.correct
df_Animal_predicted$LCI<-df_Animal_predicted$LCI-Animal.correct
df_Animal_predicted$UCI<-df_Animal_predicted$UCI-Animal.correct

#change some names to avoid conflict with similar names later on
levels(df_Animal_predicted$Variable)[levels(df_Animal_predicted$Variable)=="Other"] <- "Other animals" 


#Sex
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Sex<-expand.grid(Animal = "Rat",
     Sex =levels(dfc3_Models_clean$Sex),
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     Enflurane =0, #dummy
     Tiletamine_Zolazepam =0, #dummy
     Anaesthetic_not_reported =0, #dummy
     Other_anaesthetics =0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Sex_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Sex)
# generate lower confidence intervals by subtracting standard errors
Sex_LCI_untransformed <- Sex_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Sex, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Sex_UCI_untransformed<-Sex_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Sex, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Sex_predicted <- data.frame(grid_Sex$Sex, Sex_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Sex_LCI_untransformed^(1/Selected.lambda_clean),
                                  Sex_UCI_untransformed^(1/Selected.lambda_clean))

# Change the column names
colnames(df_Sex_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
Sex.correct<- df_Sex_predicted[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Sex_predicted$Infarct_volume<-df_Sex_predicted$Infarct_volume-Sex.correct
df_Sex_predicted$LCI<-df_Sex_predicted$LCI-Sex.correct
df_Sex_predicted$UCI<-df_Sex_predicted$UCI-Sex.correct

#change some names to avoid conflict with similar names later on
levels(df_Sex_predicted$Variable)[levels(df_Sex_predicted$Variable)=="Not reported"] <- "Sex not reported" 


# Comorbidity
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Comorbidity<-expand.grid(Animal = "Rat",
     Sex = "Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = levels(dfc3_Models_clean$Comorbidity),
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     Enflurane =0, #dummy
     Tiletamine_Zolazepam =0, #dummy
     Anaesthetic_not_reported =0, #dummy
     Other_anaesthetics =0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Comorbidity_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Comorbidity)
# generate lower confidence intervals by subtracting standard errors
Comorbidity_LCI_untransformed <- Comorbidity_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Comorbidity, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Comorbidity_UCI_untransformed<-Comorbidity_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Comorbidity, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Comorbidity_predicted <- data.frame(grid_Comorbidity$Comorbidity, Comorbidity_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Comorbidity_LCI_untransformed^(1/Selected.lambda_clean),
                                  Comorbidity_UCI_untransformed^(1/Selected.lambda_clean))

# Change the column names
colnames(df_Comorbidity_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
Comorbidity.correct<- df_Comorbidity_predicted[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Comorbidity_predicted$Infarct_volume<-df_Comorbidity_predicted$Infarct_volume-Comorbidity.correct
df_Comorbidity_predicted$LCI<-df_Comorbidity_predicted$LCI-Comorbidity.correct
df_Comorbidity_predicted$UCI<-df_Comorbidity_predicted$UCI-Comorbidity.correct

#change some names to avoid conflict with similar names later on
levels(df_Comorbidity_predicted$Variable)[levels(df_Comorbidity_predicted$Variable)=="Other"] <- "Other comorbidities" 

```

```{r Dataframes_predicted_measure_surgery, include=FALSE}

# Measurement*Surgery (interaction)
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Measure_Surgery<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = levels(dfc3_Models_clean$Infarct_measurement),
     Surgical_level = levels(dfc3_Models_clean$Surgical_level),
     Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     Enflurane =0, #dummy
     Tiletamine_Zolazepam =0, #dummy
     Anaesthetic_not_reported =0, #dummy
     Other_anaesthetics =0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Measure_Surgery_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Measure_Surgery)
# generate lower confidence intervals by subtracting standard errors
Measure_Surgery_LCI_untransformed <- Measure_Surgery_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Measure_Surgery, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Measure_Surgery_UCI_untransformed<-Measure_Surgery_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Measure_Surgery, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Measure_Surgery_predicted <- data.frame(grid_Measure_Surgery$Infarct_measurement,
                                           grid_Measure_Surgery$Surgical_level,
                                           Measure_Surgery_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Measure_Surgery_LCI_untransformed^(1/Selected.lambda_clean),
                                  Measure_Surgery_UCI_untransformed^(1/Selected.lambda_clean))

# Change the column names
colnames(df_Measure_Surgery_predicted)<-c("Infarct_measurement", "Surgical_level", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume

#combine the two column names into one
df_Measure_Surgery_predicted$Variable <- paste(df_Measure_Surgery_predicted$Infarct_measurement,
                                               df_Measure_Surgery_predicted$Surgical_level, 
                                               sep = " + ")
#delete unused columns
df_Measure_Surgery_predicted_trim <- df_Measure_Surgery_predicted[,c(6, 3, 4, 5)]


Measure_Surgery.correct<- df_Measure_Surgery_predicted_trim[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Measure_Surgery_predicted_trim$Infarct_volume<-df_Measure_Surgery_predicted_trim$Infarct_volume-Measure_Surgery.correct
df_Measure_Surgery_predicted_trim$LCI<-df_Measure_Surgery_predicted_trim$LCI-Measure_Surgery.correct
df_Measure_Surgery_predicted_trim$UCI<-df_Measure_Surgery_predicted_trim$UCI-Measure_Surgery.correct



# Surgery only
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Surgery_only<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = levels(dfc3_Models_clean$Surgical_level),
     Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     Enflurane =0, #dummy
     Tiletamine_Zolazepam =0, #dummy
     Anaesthetic_not_reported =0, #dummy
     Other_anaesthetics =0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Surgery_only_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Surgery_only)
# generate lower confidence intervals by subtracting standard errors
Surgery_only_LCI_untransformed <- Surgery_only_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Surgery_only, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Surgery_only_UCI_untransformed<-Surgery_only_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Surgery_only, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Surgery_only_predicted <- data.frame(grid_Surgery_only$Surgical_level, Surgery_only_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Surgery_only_LCI_untransformed^(1/Selected.lambda_clean),
                                  Surgery_only_UCI_untransformed^(1/Selected.lambda_clean))

# Change the column names
colnames(df_Surgery_only_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
Surgery_only.correct<- df_Surgery_only_predicted[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Surgery_only_predicted$Infarct_volume<-df_Surgery_only_predicted$Infarct_volume-Surgery_only.correct
df_Surgery_only_predicted$LCI<-df_Surgery_only_predicted$LCI-Surgery_only.correct
df_Surgery_only_predicted$UCI<-df_Surgery_only_predicted$UCI-Surgery_only.correct

#change some names to avoid conflict with similar names later on
levels(df_Surgery_only_predicted$Variable)[levels(df_Surgery_only_predicted$Variable)=="Other"] <- "Other surgical methods" 


# Infarct Measurement Method only
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Measure_only<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = levels(dfc3_Models_clean$Infarct_measurement),
     Surgical_level = "Scalp retracted, skull intact",
     Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     Enflurane =0, #dummy
     Tiletamine_Zolazepam =0, #dummy
     Anaesthetic_not_reported =0, #dummy
     Other_anaesthetics =0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Measure_only_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Measure_only)
# generate lower confidence intervals by subtracting standard errors
Measure_only_LCI_untransformed <- Measure_only_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Measure_only, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Measure_only_UCI_untransformed<-Measure_only_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Measure_only, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Measure_only_predicted <- data.frame(grid_Measure_only$Infarct_measurement, 
                                        Measure_only_predicted_untransformed^(1/Selected.lambda_clean),
                                        Measure_only_LCI_untransformed^(1/Selected.lambda_clean),
                                        Measure_only_UCI_untransformed^(1/Selected.lambda_clean))

# Change the column names
colnames(df_Measure_only_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
Measure_only.correct<- df_Measure_only_predicted[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Measure_only_predicted$Infarct_volume<-df_Measure_only_predicted$Infarct_volume-Measure_only.correct
df_Measure_only_predicted$LCI<-df_Measure_only_predicted$LCI-Measure_only.correct
df_Measure_only_predicted$UCI<-df_Measure_only_predicted$UCI-Measure_only.correct

```

```{r Dataframes_predicted_anaesthetics, include=FALSE}
# Figure 3 is predicted values plot with anaesthetics and Rose Bengal doses

#All Anaesthetics

# Isoflurane
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Isoflurane<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide = 0, #dummy
     Halothane = 0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital = 0, #dummy
     Enflurane = 0, #dummy
     Tiletamine_Zolazepam = 0, #dummy
     Anaesthetic_not_reported = 0, #dummy
     Other_anaesthetics = 0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Isoflurane_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Isoflurane)
# generate lower confidence intervals by subtracting standard errors
Isoflurane_LCI_untransformed <- Isoflurane_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Isoflurane, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Isoflurane_UCI_untransformed<-Isoflurane_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Isoflurane, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Isoflurane_predicted <- data.frame(grid_Isoflurane$Isoflurane, Isoflurane_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Isoflurane_LCI_untransformed^(1/Selected.lambda_clean),
                                  Isoflurane_UCI_untransformed^(1/Selected.lambda_clean))
# Change the column names
colnames(df_Isoflurane_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#Change dummy variable name to anaesthetic name
df_Isoflurane_predicted[1,1] <- "Isoflurane" #row one column one


# Ketamine
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Ketamine<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 0, #isoflurane is our base anaesthetic
     Ketamine = 1, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide = 0, #dummy
     Halothane = 0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital = 0, #dummy
     Enflurane = 0, #dummy
     Tiletamine_Zolazepam = 0, #dummy
     Anaesthetic_not_reported = 0, #dummy
     Other_anaesthetics = 0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Ketamine_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Ketamine)
# generate lower confidence intervals by subtracting standard errors
Ketamine_LCI_untransformed <- Ketamine_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Ketamine, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Ketamine_UCI_untransformed<-Ketamine_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Ketamine, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Ketamine_predicted <- data.frame(grid_Ketamine$Ketamine, Ketamine_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Ketamine_LCI_untransformed^(1/Selected.lambda_clean),
                                  Ketamine_UCI_untransformed^(1/Selected.lambda_clean))
# Change the column names
colnames(df_Ketamine_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#Change dummy variable name to anaesthetic name
df_Ketamine_predicted[1,1] <- "Ketamine" #row one column one


# Xylazine
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Xylazine<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 0, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 1, #dummy
     Nitrous_oxide = 0, #dummy
     Halothane = 0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital = 0, #dummy
     Enflurane = 0, #dummy
     Tiletamine_Zolazepam = 0, #dummy
     Anaesthetic_not_reported = 0, #dummy
     Other_anaesthetics = 0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Xylazine_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Xylazine)
# generate lower confidence intervals by subtracting standard errors
Xylazine_LCI_untransformed <- Xylazine_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Xylazine, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Xylazine_UCI_untransformed<-Xylazine_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Xylazine, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Xylazine_predicted <- data.frame(grid_Xylazine$Xylazine, Xylazine_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Xylazine_LCI_untransformed^(1/Selected.lambda_clean),
                                  Xylazine_UCI_untransformed^(1/Selected.lambda_clean))
# Change the column names
colnames(df_Xylazine_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#Change dummy variable name to anaesthetic name
df_Xylazine_predicted[1,1] <- "Xylazine" #row one column one


# Nitrous_oxide
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Nitrous_oxide<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 0, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide = 1, #dummy
     Halothane = 0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital = 0, #dummy
     Enflurane = 0, #dummy
     Tiletamine_Zolazepam = 0, #dummy
     Anaesthetic_not_reported = 0, #dummy
     Other_anaesthetics = 0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Nitrous_oxide_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Nitrous_oxide)
# generate lower confidence intervals by subtracting standard errors
Nitrous_oxide_LCI_untransformed <- Nitrous_oxide_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Nitrous_oxide, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Nitrous_oxide_UCI_untransformed<-Nitrous_oxide_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Nitrous_oxide, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Nitrous_oxide_predicted <- data.frame(grid_Nitrous_oxide$Nitrous_oxide, Nitrous_oxide_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Nitrous_oxide_LCI_untransformed^(1/Selected.lambda_clean),
                                  Nitrous_oxide_UCI_untransformed^(1/Selected.lambda_clean))
# Change the column names
colnames(df_Nitrous_oxide_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#Change dummy variable name to anaesthetic name
df_Nitrous_oxide_predicted[1,1] <- "Nitrous oxide" #row one column one

# Halothane
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Halothane<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 0, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide = 0, #dummy
     Halothane = 1, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital = 0, #dummy
     Enflurane = 0, #dummy
     Tiletamine_Zolazepam = 0, #dummy
     Anaesthetic_not_reported = 0, #dummy
     Other_anaesthetics = 0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Halothane_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Halothane)
# generate lower confidence intervals by subtracting standard errors
Halothane_LCI_untransformed <- Halothane_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Halothane, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Halothane_UCI_untransformed<-Halothane_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Halothane, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Halothane_predicted <- data.frame(grid_Halothane$Halothane, Halothane_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Halothane_LCI_untransformed^(1/Selected.lambda_clean),
                                  Halothane_UCI_untransformed^(1/Selected.lambda_clean))
# Change the column names
colnames(df_Halothane_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#Change dummy variable name to anaesthetic name
df_Halothane_predicted[1,1] <- "Halothane" #row one column one

# Chloral_hydrate
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Chloral_hydrate<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 0, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide = 0, #dummy
     Halothane = 0, #dummy
     Chloral_hydrate = 1, #dummy
     Sodium_pentobarbital = 0, #dummy
     Enflurane = 0, #dummy
     Tiletamine_Zolazepam = 0, #dummy
     Anaesthetic_not_reported = 0, #dummy
     Other_anaesthetics = 0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Chloral_hydrate_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Chloral_hydrate)
# generate lower confidence intervals by subtracting standard errors
Chloral_hydrate_LCI_untransformed <- Chloral_hydrate_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Chloral_hydrate, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Chloral_hydrate_UCI_untransformed<-Chloral_hydrate_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Chloral_hydrate, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Chloral_hydrate_predicted <- data.frame(grid_Chloral_hydrate$Chloral_hydrate, Chloral_hydrate_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Chloral_hydrate_LCI_untransformed^(1/Selected.lambda_clean),
                                  Chloral_hydrate_UCI_untransformed^(1/Selected.lambda_clean))
# Change the column names
colnames(df_Chloral_hydrate_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#Change dummy variable name to anaesthetic name
df_Chloral_hydrate_predicted[1,1] <- "Chloral hydrate" #row one column one


# Sodium_pentobarbital
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Sodium_pentobarbital<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 0, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide = 0, #dummy
     Halothane = 0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital = 1, #dummy
     Enflurane = 0, #dummy
     Tiletamine_Zolazepam = 0, #dummy
     Anaesthetic_not_reported = 0, #dummy
     Other_anaesthetics = 0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Sodium_pentobarbital_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Sodium_pentobarbital)
# generate lower confidence intervals by subtracting standard errors
Sodium_pentobarbital_LCI_untransformed <- Sodium_pentobarbital_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Sodium_pentobarbital, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Sodium_pentobarbital_UCI_untransformed<-Sodium_pentobarbital_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Sodium_pentobarbital, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Sodium_pentobarbital_predicted <- data.frame(grid_Sodium_pentobarbital$Sodium_pentobarbital, Sodium_pentobarbital_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Sodium_pentobarbital_LCI_untransformed^(1/Selected.lambda_clean),
                                  Sodium_pentobarbital_UCI_untransformed^(1/Selected.lambda_clean))
# Change the column names
colnames(df_Sodium_pentobarbital_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#Change dummy variable name to anaesthetic name
df_Sodium_pentobarbital_predicted[1,1] <- "Sodium pentobarbital" #row one column one


# Enflurane
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Enflurane<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 0, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide = 0, #dummy
     Halothane = 0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital = 0, #dummy
     Enflurane = 1, #dummy
     Tiletamine_Zolazepam = 0, #dummy
     Anaesthetic_not_reported = 0, #dummy
     Other_anaesthetics = 0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Enflurane_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Enflurane)
# generate lower confidence intervals by subtracting standard errors
Enflurane_LCI_untransformed <- Enflurane_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Enflurane, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Enflurane_UCI_untransformed<-Enflurane_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Enflurane, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Enflurane_predicted <- data.frame(grid_Enflurane$Enflurane, Enflurane_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Enflurane_LCI_untransformed^(1/Selected.lambda_clean),
                                  Enflurane_UCI_untransformed^(1/Selected.lambda_clean))
# Change the column names
colnames(df_Enflurane_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#Change dummy variable name to anaesthetic name
df_Enflurane_predicted[1,1] <- "Enflurane" #row one column one

# Tiletamine_Zolazepam
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Tiletamine_Zolazepam<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 0, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide = 0, #dummy
     Halothane = 0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital = 0, #dummy
     Enflurane = 0, #dummy
     Tiletamine_Zolazepam = 1, #dummy
     Anaesthetic_not_reported = 0, #dummy
     Other_anaesthetics = 0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Tiletamine_Zolazepam_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Tiletamine_Zolazepam)
# generate lower confidence intervals by subtracting standard errors
Tiletamine_Zolazepam_LCI_untransformed <- Tiletamine_Zolazepam_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Tiletamine_Zolazepam, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Tiletamine_Zolazepam_UCI_untransformed<-Tiletamine_Zolazepam_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Tiletamine_Zolazepam, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Tiletamine_Zolazepam_predicted <- data.frame(grid_Tiletamine_Zolazepam$Tiletamine_Zolazepam, Tiletamine_Zolazepam_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Tiletamine_Zolazepam_LCI_untransformed^(1/Selected.lambda_clean),
                                  Tiletamine_Zolazepam_UCI_untransformed^(1/Selected.lambda_clean))
# Change the column names
colnames(df_Tiletamine_Zolazepam_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#Change dummy variable name to anaesthetic name
df_Tiletamine_Zolazepam_predicted[1,1] <- "Tiletamine-Zolazepam" #row one column one

# Anaesthetic_not_reported
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Anaesthetic_not_reported<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 0, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide = 0, #dummy
     Halothane = 0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital = 0, #dummy
     Enflurane = 0, #dummy
     Tiletamine_Zolazepam = 0, #dummy
     Anaesthetic_not_reported = 1, #dummy
     Other_anaesthetics = 0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Anaesthetic_not_reported_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Anaesthetic_not_reported)
# generate lower confidence intervals by subtracting standard errors
Anaesthetic_not_reported_LCI_untransformed <- Anaesthetic_not_reported_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Anaesthetic_not_reported, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Anaesthetic_not_reported_UCI_untransformed<-Anaesthetic_not_reported_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Anaesthetic_not_reported, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Anaesthetic_not_reported_predicted <- data.frame(grid_Anaesthetic_not_reported$Anaesthetic_not_reported, Anaesthetic_not_reported_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Anaesthetic_not_reported_LCI_untransformed^(1/Selected.lambda_clean),
                                  Anaesthetic_not_reported_UCI_untransformed^(1/Selected.lambda_clean))
# Change the column names
colnames(df_Anaesthetic_not_reported_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#Change dummy variable name to anaesthetic name
df_Anaesthetic_not_reported_predicted[1,1] <- "Anaesthetic not reported" #row one column one


# Other_anaesthetics
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Other_anaesthetics<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 0, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide = 0, #dummy
     Halothane = 0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital = 0, #dummy
     Enflurane = 0, #dummy
     Tiletamine_Zolazepam = 0, #dummy
     Anaesthetic_not_reported = 0, #dummy
     Other_anaesthetics = 1,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Other_anaesthetics_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Other_anaesthetics)
# generate lower confidence intervals by subtracting standard errors
Other_anaesthetics_LCI_untransformed <- Other_anaesthetics_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Other_anaesthetics, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Other_anaesthetics_UCI_untransformed<-Other_anaesthetics_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Other_anaesthetics, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Other_anaesthetics_predicted <- data.frame(grid_Other_anaesthetics$Other_anaesthetics, Other_anaesthetics_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Other_anaesthetics_LCI_untransformed^(1/Selected.lambda_clean),
                                  Other_anaesthetics_UCI_untransformed^(1/Selected.lambda_clean))
# Change the column names
colnames(df_Other_anaesthetics_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#Change dummy variable name to anaesthetic name
df_Other_anaesthetics_predicted[1,1] <- "Other anaesthetics" #row one column one

#combine all anaesthetics into one dataframe
df_Anaesthetics_predicted <- rbind(df_Isoflurane_predicted, 
                                   df_Ketamine_predicted,
                                   df_Xylazine_predicted,
                                   df_Nitrous_oxide_predicted,
                                   df_Halothane_predicted, 
                                   df_Chloral_hydrate_predicted,
                                   df_Sodium_pentobarbital_predicted,
                                   df_Enflurane_predicted,
                                   df_Tiletamine_Zolazepam_predicted,
                                   df_Anaesthetic_not_reported_predicted,
                                   df_Other_anaesthetics_predicted)


#select the baseline variable infarct volume
Anaesthetics.correct<- df_Anaesthetics_predicted[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Anaesthetics_predicted$Infarct_volume<-df_Anaesthetics_predicted$Infarct_volume-Anaesthetics.correct
df_Anaesthetics_predicted$LCI<-df_Anaesthetics_predicted$LCI-Anaesthetics.correct
df_Anaesthetics_predicted$UCI<-df_Anaesthetics_predicted$UCI-Anaesthetics.correct

```

```{r Dataframes_predicted_RB_dose, include=FALSE}
#RB_dose_mgkg_cat
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_RB_dose<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide = 0, #dummy
     Halothane = 0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital = 0, #dummy
     Enflurane = 0, #dummy
     Tiletamine_Zolazepam =0, #dummy
     Anaesthetic_not_reported = 0, #dummy
     Other_anaesthetics = 0,
     RB_dose_mgkg_cat = levels(dfc3_Models_clean$RB_dose_mgkg_cat), 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
RB_dose_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_RB_dose)
# generate lower confidence intervals by subtracting standard errors
RB_dose_LCI_untransformed <- RB_dose_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_RB_dose, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
RB_dose_UCI_untransformed<-RB_dose_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_RB_dose, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_RB_dose_predicted <- data.frame(grid_RB_dose$RB_dose_mgkg_cat, RB_dose_predicted_untransformed^(1/Selected.lambda_clean), 
                                  RB_dose_LCI_untransformed^(1/Selected.lambda_clean),
                                  RB_dose_UCI_untransformed^(1/Selected.lambda_clean))

# Change the column names
colnames(df_RB_dose_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
RB_dose.correct<- df_RB_dose_predicted[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_RB_dose_predicted$Infarct_volume<-df_RB_dose_predicted$Infarct_volume-RB_dose.correct
df_RB_dose_predicted$LCI<-df_RB_dose_predicted$LCI-RB_dose.correct
df_RB_dose_predicted$UCI<-df_RB_dose_predicted$UCI-RB_dose.correct

#change some names to avoid conflict with similar names later on
levels(df_RB_dose_predicted$Variable)[levels(df_RB_dose_predicted$Variable)=="Not reported"] <- "Dose not reported"

```

```{r Dataframes_predicted_light_categoricals, include=FALSE}

#Light_source
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Light_source<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     Enflurane =0, #dummy
     Tiletamine_Zolazepam =0, #dummy
     Anaesthetic_not_reported =0, #dummy
     Other_anaesthetics =0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = levels(dfc3_Models_clean$Light_source),
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Light_source_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Light_source)
# generate lower confidence intervals by subtracting standard errors
Light_source_LCI_untransformed <- Light_source_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Light_source, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Light_source_UCI_untransformed<-Light_source_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Light_source, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Light_source_predicted <- data.frame(grid_Light_source$Light_source, Light_source_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Light_source_LCI_untransformed^(1/Selected.lambda_clean),
                                  Light_source_UCI_untransformed^(1/Selected.lambda_clean))

# Change the column names
colnames(df_Light_source_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
Light_source.correct<- df_Light_source_predicted[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Light_source_predicted$Infarct_volume<-df_Light_source_predicted$Infarct_volume-Light_source.correct
df_Light_source_predicted$LCI<-df_Light_source_predicted$LCI-Light_source.correct
df_Light_source_predicted$UCI<-df_Light_source_predicted$UCI-Light_source.correct

#change some names to avoid conflict with similar names later on
levels(df_Light_source_predicted$Variable)[levels(df_Light_source_predicted$Variable)=="Other"] <- "Other light source" 
levels(df_Light_source_predicted$Variable)[levels(df_Light_source_predicted$Variable)=="Not reported"] <- "Light source not reported"


#Light_aperture_cat
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Light_aperture<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     Enflurane =0, #dummy
     Tiletamine_Zolazepam =0, #dummy
     Anaesthetic_not_reported =0, #dummy
     Other_anaesthetics =0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = levels(dfc3_Models_clean$Light_aperture_cat),
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Light_aperture_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Light_aperture)
# generate lower confidence intervals by subtracting standard errors
Light_aperture_LCI_untransformed <- Light_aperture_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Light_aperture, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Light_aperture_UCI_untransformed<-Light_aperture_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Light_aperture, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Light_aperture_predicted <- data.frame(grid_Light_aperture$Light_aperture_cat, Light_aperture_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Light_aperture_LCI_untransformed^(1/Selected.lambda_clean),
                                  Light_aperture_UCI_untransformed^(1/Selected.lambda_clean))

# Change the column names
colnames(df_Light_aperture_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
Light_aperture.correct<- df_Light_aperture_predicted[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Light_aperture_predicted$Infarct_volume<-df_Light_aperture_predicted$Infarct_volume-Light_aperture.correct
df_Light_aperture_predicted$LCI<-df_Light_aperture_predicted$LCI-Light_aperture.correct
df_Light_aperture_predicted$UCI<-df_Light_aperture_predicted$UCI-Light_aperture.correct

#change some names to avoid conflict with similar names later on
levels(df_Light_aperture_predicted$Variable)[levels(df_Light_aperture_predicted$Variable)=="Not reported"] <- "Light aperture not reported"


#Light_time_cat
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Light_time<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, #picking 24 as baseline for infarct time
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     Enflurane =0, #dummy
     Tiletamine_Zolazepam =0, #dummy
     Anaesthetic_not_reported =0, #dummy
     Other_anaesthetics =0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= levels(dfc3_Models_clean$Light_time_cat), 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Light_time_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Light_time)
# generate lower confidence intervals by subtracting standard errors
Light_time_LCI_untransformed <- Light_time_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Light_time, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Light_time_UCI_untransformed<-Light_time_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Light_time, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Light_time_predicted <- data.frame(grid_Light_time$Light_time_cat, Light_time_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Light_time_LCI_untransformed^(1/Selected.lambda_clean),
                                  Light_time_UCI_untransformed^(1/Selected.lambda_clean))

# Change the column names
colnames(df_Light_time_predicted)<-c("Variable", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
Light_time.correct<- df_Light_time_predicted[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Light_time_predicted$Infarct_volume<-df_Light_time_predicted$Infarct_volume-Light_time.correct
df_Light_time_predicted$LCI<-df_Light_time_predicted$LCI-Light_time.correct
df_Light_time_predicted$UCI<-df_Light_time_predicted$UCI-Light_time.correct

#change some names to avoid conflict with similar names later on
levels(df_Light_time_predicted$Variable)[levels(df_Light_time_predicted$Variable)=="Not reported"] <- "Light time not reported"

```

```{r Combine_predicted_dataframes, include=FALSE}
#data for prediction plot  1
df_pplot1 <- rbind(df_Animal_predicted,
                 df_Sex_predicted,
                 df_Comorbidity_predicted)
rownames(df_pplot1)<-1:nrow(df_pplot1) #rows were numbered poorly, number them all from 1 up
levels(df_pplot1$Variable)
#make groups for variables
df_pplot1$Category <- ifelse(df_pplot1$Variable %in% c("Rat", "Mouse", "Other animals"),
                              "Animal",
                              ifelse(df_pplot1$Variable %in% c("Male", "Female", "Mixed", "Sex not reported"),
                                     "Sex", 
                                     ifelse(df_pplot1$Variable %in% c("None", 
                                                                      "Hypertension", 
                                                                      "Aged", 
                                                                      "Other comorbidities"),
                                     "Comorbidities", NA)))

# Make df for 'surgery x measure + surgery only'
df_pplot1b <- rbind(df_Measure_Surgery_predicted_trim,
                    df_Surgery_only_predicted)
rownames(df_pplot1b)<-1:nrow(df_pplot1b) #rows were numbered poorly, number them all from 1 up
levels(df_pplot1b$Variable)
#make groups for variables
df_pplot1b$Category <- ifelse(df_pplot1b$Variable %in% c("Scalp retracted, skull intact",
                                                         "Other histology (ex vivo) + Scalp retracted, skull intact",
                                                         "TTC (ex vivo) + Scalp retracted, skull intact",
                                                         "MRI (in vivo) + Scalp retracted, skull intact"),
                              "Scalp retracted, skull intact",
                              ifelse(df_pplot1b$Variable %in% c("Skull thinned", 
                                                               "Other histology (ex vivo) + Skull thinned",
                                                               "TTC (ex vivo) + Skull thinned",
                                                               "MRI (in vivo) + Skull thinned"),
                                     "Skull thinned", 
                                     ifelse(df_pplot1b$Variable %in% c("Skull breached",
                                                                      "Other histology (ex vivo) + Skull breached",
                                                                      "TTC (ex vivo) + Skull breached",
                                                                      "MRI (in vivo) + Skull breached"),
                                     "Skull breached", 
                                     ifelse(df_pplot1b$Variable %in% c("Other surgical methods",
                                                                      "Other histology (ex vivo) + Other",
                                                                      "TTC (ex vivo) + Other",
                                                                      "MRI (in vivo) + Other"),
                                     "Other surgical methods", NA))))
#order the categories for the graph
df_pplot1$Category <- factor(df_pplot1$Category, levels=c("Animal", "Sex", "Comorbidity"))

# #order surgery x measure  + surgery only variables
df_pplot1b$Variable <- factor(df_pplot1b$Variable, levels=c(
                                                          "Scalp retracted, skull intact",
                                                          "Other histology (ex vivo) + Scalp retracted, skull intact",
                                                          "TTC (ex vivo) + Scalp retracted, skull intact",
                                                          "MRI (in vivo) + Scalp retracted, skull intact",
                                                          "Skull thinned",
                                                          "Other histology (ex vivo) + Skull thinned",
                                                          "TTC (ex vivo) + Skull thinned",
                                                          "MRI (in vivo) + Skull thinned",
                                                          "Skull breached",
                                                          "Other histology (ex vivo) + Skull breached",
                                                          "TTC (ex vivo) + Skull breached",
                                                          "MRI (in vivo) + Skull breached",
                                                          "Other surgical methods",
                                                          "Other histology (ex vivo) + Other",
                                                          "TTC (ex vivo) + Other",
                                                          "MRI (in vivo) + Other"))
#reorder category factor
df_pplot1b$Category <- factor(df_pplot1b$Category, levels=c("Scalp retracted, skull intact",
                                                            "Skull thinned",
                                                            "Skull breached",
                                                            "Other surgical methods"))


# Make df for surgery only + measure only + animal + sex + comorbidity
df_pplot_ms <- rbind(df_Animal_predicted,
                     df_Sex_predicted,
                     df_Comorbidity_predicted,
                     df_Measure_only_predicted,
                     df_Surgery_only_predicted)
rownames(df_pplot_ms)<-1:nrow(df_pplot_ms) #rows were numbered poorly, number them all from 1 up
levels(df_pplot_ms$Variable)
#make groups for variables
df_pplot_ms$Category <- ifelse(df_pplot_ms$Variable %in% c("Rat", "Mouse", "Other animals"),
                              "Animal",
                              ifelse(df_pplot_ms$Variable %in% c("Male", "Female", "Mixed", "Sex not reported"),
                                     "Sex", 
                                     ifelse(df_pplot_ms$Variable %in% c("None", 
                                                                      "Hypertension", 
                                                                      "Aged", 
                                                                      "Other comorbidities"),
                                     "Comorbidities",
                                      ifelse(df_pplot_ms$Variable %in% c("Other histology (ex vivo)", 
                                                                 "TTC (ex vivo)", 
                                                                 "MRI (in vivo)"),
                                     "Measurement method",
                                     ifelse(df_pplot_ms$Variable %in% c("Scalp retracted, skull intact", 
                                                                 "Skull thinned", 
                                                                 "Skull breached", 
                                                                 "Other surgical methods"),
                                     "Surgical method", NA)))))
#reorder surgery only + measure only + animal + sex + comorbidity+ animal + sex + comorbidity category factor
df_pplot_ms$Category <- factor(df_pplot_ms$Category, levels=c("Animal",
                                                              "Sex",
                                                              "Surgical method",
                                                              "Comorbidities",
                                                              "Measurement method"))

# # #order surgery only + measure only variables
# df_pplot_ms$Variable <- factor(df_pplot_ms$Variable, levels=c(
#                                                           "Scalp retracted, skull intact",
#                                                           "Skull thinned",
#                                                           "Skull breached",
#                                                           "Other surgical methods",
#                                                           "Other histology (ex vivo)", 
#                                                            "TTC (ex vivo)", 
#                                                            "MRI (in vivo)"))



#data for prediction plot 2
df_pplot2 <- rbind(df_Anaesthetics_predicted,
                 df_RB_dose_predicted)
rownames(df_pplot2)<-1:nrow(df_pplot2) #rows were numbered poorly, number them all from 1 up
df_pplot2$Variable <- factor(df_pplot2$Variable, 
                             levels = unique(df_pplot2$Variable)[order(1:nrow(df_pplot2))]) #make a factor then order by row number
levels(df_pplot2$Variable)
summary(df_pplot2$Variable)
#make groups for variables
df_pplot2$Category <- ifelse(df_pplot2$Variable %in% c("Isoflurane", 
                                                "Ketamine", 
                                                "Xylazine",
                                                "Nitrous oxide",
                                                "Halothane",
                                                "Chloral hydrate",
                                                "Sodium pentobarbital",
                                                "Enflurane",
                                                "Tiletamine-Zolazepam",
                                                "Anaesthetic not reported",
                                                "Other anaesthetics"),
                              "Anaesthetic",
                              ifelse(df_pplot2$Variable %in% c("0.1-15mg/kg", 
                                                     "15-30mg/kg", 
                                                     "30-45mg/kg", 
                                                     "45-60mg/kg",
                                                     "60-75mg/kg",
                                                     "75+mg/kg",
                                                     "Dose not reported"),
                                     "Rose Bengal dose", NA))


#data for prediction plot 3
df_pplot3 <- rbind(df_Light_source_predicted,
                   df_Light_aperture_predicted,
                   df_Light_time_predicted)
rownames(df_pplot3)<-1:nrow(df_pplot3) #rows were numbered poorly, number them all from 1 up
levels(df_pplot3$Variable)
#make groups for variables
df_pplot3$Category <- ifelse(df_pplot3$Variable %in% c('Xenon',
                                                       'Cold light (unspecified)',
                                                       'Green laser (unspecified)',
                                                       'Halogen',
                                                       'Diode laser (unspecified)',
                                                       'Krypton laser',
                                                       'LED',
                                                       "Other light source",
                                                       "Light source not reported"),
                              "Light source",
                              ifelse(df_pplot3$Variable %in% c("0.02-1mm", 
                                                     "1-2mm", 
                                                     "2-3mm", 
                                                     "3-4mm",
                                                     "4-5mm",
                                                     "5+mm",
                                                     "Light aperture not reported"),
                                     "Light aperture", 
                                     ifelse(df_pplot3$Variable %in% c("0.5-5mins",
                                                        "5-10mins",
                                                        "10-15mins",
                                                        "15-20mins",
                                                        "20+mins",
                                                        "Light time not reported"),
                                     "Light exposure time", NA)))


```

```{r Expected_brain_volume, include=FALSE}
# Expected value of brain volume (essentially mean) - absolute value
Expected_brain_vol <- (mean(dfc3_Models_clean$Infarct_percent_control^Selected.lambda_clean))^(1/Selected.lambda_clean) #mean
Expected_brain_vol_SD <- (sd(dfc3_Models_clean$Infarct_percent_control^Selected.lambda_clean))^(1/Selected.lambda_clean) #standard deviation of 

# Brain volume as a percentage of "average" brain volume
Expected_brain_vol_percent <- (100/Expected_brain_vol)

summary(dfc3_Models_clean$Comorbidity)

```


#Prediction plots for categorical variables

```{r Prediction_plot_categorical_animal, include=FALSE, eval=FALSE}

# First categorical prediction plot, contains animal, sex, comorbidities, surgery, and measurement
#transform all y variables into percentage of average infarct volume
pdf("Categorical_predicted_Animal_4.pdf", height = 7, width = 7)
  ggplot(data=df_pplot_ms, aes(x=Variable, y=Infarct_volume*Expected_brain_vol_percent, 
                             ymin=LCI*Expected_brain_vol_percent, ymax=UCI*Expected_brain_vol_percent)) + #add colour = Category to aes() for colouring the groups
  geom_pointrange() + #points with error ranges style graph
  scale_x_discrete(limits=rev) + #flip the x axis (about to become y axis) so it reads top to bottom - only reverses within faceted groups
  coord_flip() + # flip coordinates (puts labels on y axis)
  # scale_colour_viridis_d(option="plasma") + # colour the groups with viridis plasma
  geom_hline(yintercept=0, lty=2, size =1) +  # add a dotted line at x=0 after flip
  geom_errorbar(aes(ymin=LCI*Expected_brain_vol_percent, ymax=UCI*Expected_brain_vol_percent), width=0.5, cex=1) + # Makes whiskers on the range (more aesthetically pleasing)
  xlab("") + #remove main x label
  ylab("% of average infarct volume") +
  scale_y_continuous(breaks=seq(-100,175,by=25)) +
  facet_grid(rows = vars(Category), scales = "free_y", space = "free_y") + #get some space in-between the groups
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        axis.line = element_line(colour = "black"),
        strip.text.y =element_blank(), #remove facet wrap labels
        legend.position = "none")
dev.off()

```

```{r Prediction_plot_categorical_surgery*measurement, include=FALSE, eval=FALSE}

# Supplementary categorical prediction plot, contains measurement*surgery
#transform all y variables into percentage of average infarct volume
pdf("Categorical_predicted_measure+surgery_2.pdf", height = 6, width = 9)
ggplot(data=df_pplot1b, aes(x=Variable, y=Infarct_volume*Expected_brain_vol_percent, 
                             ymin=LCI*Expected_brain_vol_percent, ymax=UCI*Expected_brain_vol_percent)) + #add colour = Category to aes() for colouring the groups
  geom_pointrange() + #points with error ranges style graph
  scale_x_discrete(limits=rev) + #flip the x axis (about to become y axis) so it reads top to bottom - only reverses within faceted groups
  coord_flip() + # flip coordinates (puts labels on y axis)
  # scale_colour_viridis_d(option="plasma") + # colour the groups with viridis plasma
  geom_hline(yintercept=0, lty=2, size =1) +  # add a dotted line at x=0 after flip
  geom_errorbar(aes(ymin=LCI*Expected_brain_vol_percent, ymax=UCI*Expected_brain_vol_percent), width=0.5, cex=1) + # Makes whiskers on the range (more aesthetically pleasing)
  xlab("") + #remove main x label
  ylab("% of average infarct volume") +
  scale_y_continuous(breaks=seq(-100,500,by=50)) +
  facet_grid(rows = vars(Category), scales = "free_y", space = "free_y") + #get some space in-between the groups
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        axis.line = element_line(colour = "black"),
        strip.text.y =element_blank(), #remove facet wrap labels
        legend.position = "none") 
dev.off()

#n of each group
table(dfc3_Models_clean$Surgical_level, dfc3_Models_clean$Infarct_measurement)

```

```{r Prediction_plot_categorical_anaesthetic, include=FALSE, eval=FALSE}
# Second categorical prediction plot, contains anaesthetics + rose bengal dose
#transform all y variables into percentage of average infarct volume
pdf("Categorical_predicted_Anaesthetic_3.pdf", height = 6, width = 8)
ggplot(data=df_pplot2, aes(x=Variable, y=Infarct_volume*Expected_brain_vol_percent, 
                                     ymin=LCI*Expected_brain_vol_percent, ymax=UCI*Expected_brain_vol_percent)) + #add colour = Category to aes() for colouring the groups
  geom_pointrange() + # points with error ranges style graph
  coord_flip() + # flip coordinates (puts labels on y axis)
  scale_x_discrete(limits=rev) + #flip the x axis (about to become y axis) so it reads top to bottom - only reverses within faceted groups
  # scale_colour_viridis_d(option="plasma") + # colour the groups with viridis plasma
  geom_hline(yintercept=0, lty=2, size =1) +  # add a dotted line at x=0 after flip
  geom_errorbar(aes(ymin=LCI*Expected_brain_vol_percent, ymax=UCI*Expected_brain_vol_percent), width=0.5, cex=1) + # Makes whiskers on the range (more aesthetically pleasing)
  xlab("") + #remove main x label
  ylab("% of average infarct volume") +
  scale_y_continuous(breaks=seq(-50,50,by=10)) +
  facet_grid(rows = vars(Category), scales = "free_y", space = "free_y") + #get some space in-between the groups
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        axis.line = element_line(colour = "black"),
        strip.text.y =element_blank(), #remove facet wrap labels
        legend.position = "none")
dev.off()

```

```{r Prediction_plot_categorical_light, include=FALSE, eval=FALSE}

# Second categorical prediction plot, contains light source, light aperture, light time
#transform all y variables into percentage of average infarct volume
pdf("Categorical_predicted_Light_3.pdf", height = 6, width = 8)
ggplot(data=df_pplot3, aes(x=Variable, y=Infarct_volume*Expected_brain_vol_percent, 
                                     ymin=LCI*Expected_brain_vol_percent, ymax=UCI*Expected_brain_vol_percent)) + #add colour = Category to aes() for colouring the groups
  geom_pointrange() + #points with error ranges style graph
  coord_flip() + # flip coordinates (puts labels on y axis)
  scale_x_discrete(limits=rev) + #flip the x axis (about to become y axis) so it reads top to bottom - only reverses within faceted groups
  # scale_colour_viridis_d(option="plasma") + # colour the groups with viridis plasma
  geom_hline(yintercept=0, lty=2, size =1) +  # add a dotted line at x=0 after flip
  geom_errorbar(aes(ymin=LCI*Expected_brain_vol_percent, ymax=UCI*Expected_brain_vol_percent), width=0.5, cex=1) + # Makes whiskers on the range (more aesthetically pleasing)
  xlab("") + #remove main x label
  ylab("% of average infarct volume") +
  scale_y_continuous(breaks=seq(-100,125,by=10)) +
  facet_grid(rows = vars(Category), scales = "free_y", space = "free_y") + #get some space in-between the groups
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        axis.line = element_line(colour = "black"),
        strip.text.y =element_blank(), #remove facet wrap labels
        legend.position = "none")
dev.off()

```


#Prediction plots for continuous variables

```{r Dataframe_predicted_infarct_time, include=FALSE}
#Infarct measurement time (continuous)
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
summary(as.factor(dfc3_Models_clean$Infarct_time)) # check the range of measured times - only a few (13) go out past 30 days (720 hours)
#Remember collinearity with measurement method though
table(dfc3_Models_clean$Infarct_measurement, dfc3_Models_clean$Infarct_time)
#histology range 4 - 2016 hours
#TTC range 12 - 168 hours + 3 outliers at 336 hours and one at 1344
#MRI range from 6 to 168 hours, one outlier at 1512
#make one graph with just time, make another graph split by method.

#nifarct time alone
grid_Infarct_time<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  seq(4, 2016, by=4), # start at 4 hours (lowest), go up to 2016 (highest, but be aware not many past 720) in 4 hour increments
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     Enflurane =0, #dummy
     Tiletamine_Zolazepam =0, #dummy
     Anaesthetic_not_reported =0, #dummy
     Other_anaesthetics =0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Infarct_time_predicted_untransformed <- predict(lm_clean_transformed, newdata=grid_Infarct_time)
# generate lower confidence intervals by subtracting standard errors
Infarct_time_LCI_untransformed <- Infarct_time_predicted_untransformed-predict(lm_clean_transformed, newdata=grid_Infarct_time, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Infarct_time_UCI_untransformed<-Infarct_time_predicted_untransformed+predict(lm_clean_transformed, newdata=grid_Infarct_time, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Infarct_time_predicted <- data.frame(grid_Infarct_time$Infarct_time, Infarct_time_predicted_untransformed^(1/Selected.lambda_clean), 
                                  Infarct_time_LCI_untransformed^(1/Selected.lambda_clean),
                                  Infarct_time_UCI_untransformed^(1/Selected.lambda_clean))

# Change the column names
colnames(df_Infarct_time_predicted)<-c("Time", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
Infarct_time.correct<- df_Infarct_time_predicted[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Infarct_time_predicted$Infarct_volume<-df_Infarct_time_predicted$Infarct_volume-Infarct_time.correct
df_Infarct_time_predicted$LCI<-df_Infarct_time_predicted$LCI-Infarct_time.correct
df_Infarct_time_predicted$UCI<-df_Infarct_time_predicted$UCI-Infarct_time.correct

```

```{r Prediction plot_infarct_time, include=FALSE, eval=FALSE}
#convert infarct volume to percentage of average infarct
#convert time from hours to days
pdf("Continuous_predicted_infarct_time_6.pdf", width = 4.5, height = 4)
ggplot(df_Infarct_time_predicted, aes(x=(Time/24), y=Infarct_volume*Expected_brain_vol_percent)) +
  geom_ribbon(aes(ymax=UCI*Expected_brain_vol_percent, ymin=LCI*Expected_brain_vol_percent), 
              alpha=0.3,
              fill=plasma(4)[1]) +
  geom_line(color="#292829", size=1) +
  geom_hline(yintercept=0, lty=2, size =1) +
  scale_x_continuous(breaks=seq(0,105,by=7)) +
  scale_y_continuous(breaks=seq(-25,25,by=5)) +
  theme_classic() +
  labs(x = "Time infarct was measured (days post stroke)", 
       y = "% of average infarct volume")+
  theme(axis.ticks=element_line(color="black", lineend = "square"), #Make ticks black
        ) 
dev.off()

#check this matches crude plot
ggplot(dfc3_Models_clean, aes(x=Infarct_time, y=Infarct_percent_control)) +
  geom_point() +
  geom_smooth()

```

```{r Dataframe_predicted_infarct_time_X_measurement_method, include=FALSE}
#Infarct measurement time (continuous)
#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
summary(as.factor(dfc3_Models_clean$Infarct_time)) # check the range of measured times - only a few (13) go out past 30 days, so stopping at 720hours for robust prediction
#collinearity with measurement method though
table(dfc3_Models_clean$Infarct_measurement, dfc3_Models_clean$Infarct_time)
#histology range 4 - 2016 hours
#TTC range 12 - 168 hours + 3 outliers at 336 hours and one at 1344
#MRI range from 6 to 168 hours, one outlier at 1512

#infarct time by histology prediction
grid_Infarct_time_hist<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  seq(4, 2016, by=4), # start at 4 hours (lowest), go up to 2016 (highest)
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     Enflurane =0, #dummy
     Tiletamine_Zolazepam =0, #dummy
     Anaesthetic_not_reported =0, #dummy
     Other_anaesthetics =0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Infarct_time_predicted_untransformed_hist <- predict(lm_clean_transformed, newdata=grid_Infarct_time_hist)
# generate lower confidence intervals by subtracting standard errors
Infarct_time_LCI_untransformed_hist <- Infarct_time_predicted_untransformed_hist-predict(lm_clean_transformed, newdata=grid_Infarct_time_hist, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Infarct_time_UCI_untransformed_hist<-Infarct_time_predicted_untransformed_hist+predict(lm_clean_transformed, newdata=grid_Infarct_time_hist, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Infarct_time_predicted_hist <- data.frame(grid_Infarct_time_hist$Infarct_time, Infarct_time_predicted_untransformed_hist^(1/Selected.lambda_clean), 
                                  Infarct_time_LCI_untransformed_hist^(1/Selected.lambda_clean),
                                  Infarct_time_UCI_untransformed_hist^(1/Selected.lambda_clean))

# Change the column names
colnames(df_Infarct_time_predicted_hist)<-c("Time", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
Infarct_time.correct_hist<- df_Infarct_time_predicted_hist[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Infarct_time_predicted_hist$Infarct_volume<-df_Infarct_time_predicted_hist$Infarct_volume-Infarct_time.correct_hist
df_Infarct_time_predicted_hist$LCI<-df_Infarct_time_predicted_hist$LCI-Infarct_time.correct_hist
df_Infarct_time_predicted_hist$UCI<-df_Infarct_time_predicted_hist$UCI-Infarct_time.correct_hist



#infarct time by MRI prediction
grid_Infarct_time_mri<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  seq(4, 168, by=4), # start at 4 hours (lowest), go up to 168 (not the highest but next highest is only one entry at 1512)
     Infarct_measurement = "MRI (in vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     Enflurane =0, #dummy
     Tiletamine_Zolazepam =0, #dummy
     Anaesthetic_not_reported =0, #dummy
     Other_anaesthetics =0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Infarct_time_predicted_untransformed_mri <- predict(lm_clean_transformed, newdata=grid_Infarct_time_mri)
# generate lower confidence intervals by subtracting standard errors
Infarct_time_LCI_untransformed_mri <- Infarct_time_predicted_untransformed_mri-predict(lm_clean_transformed, newdata=grid_Infarct_time_mri, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Infarct_time_UCI_untransformed_mri<-Infarct_time_predicted_untransformed_mri+predict(lm_clean_transformed, newdata=grid_Infarct_time_mri, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Infarct_time_predicted_mri <- data.frame(grid_Infarct_time_mri$Infarct_time, Infarct_time_predicted_untransformed_mri^(1/Selected.lambda_clean), 
                                  Infarct_time_LCI_untransformed_mri^(1/Selected.lambda_clean),
                                  Infarct_time_UCI_untransformed_mri^(1/Selected.lambda_clean))

# Change the column names
colnames(df_Infarct_time_predicted_mri)<-c("Time", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
#Infarct_time.correct_mri<- df_Infarct_time_predicted_mri[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 (of other histology, not ttc or mri)
df_Infarct_time_predicted_mri$Infarct_volume<-df_Infarct_time_predicted_mri$Infarct_volume-Infarct_time.correct_hist
df_Infarct_time_predicted_mri$LCI<-df_Infarct_time_predicted_mri$LCI-Infarct_time.correct_hist
df_Infarct_time_predicted_mri$UCI<-df_Infarct_time_predicted_mri$UCI-Infarct_time.correct_hist




#infarct time by TTC prediction
grid_Infarct_time_ttc<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  seq(4, 336, by=4), # start at 4 hours (lowest), go up to 336 (highest)
     Infarct_measurement = "TTC (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     Enflurane =0, #dummy
     Tiletamine_Zolazepam =0, #dummy
     Anaesthetic_not_reported =0, #dummy
     Other_anaesthetics =0,
     RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Infarct_time_predicted_untransformed_ttc <- predict(lm_clean_transformed, newdata=grid_Infarct_time_ttc)
# generate lower confidence intervals by subtracting standard errors
Infarct_time_LCI_untransformed_ttc <- Infarct_time_predicted_untransformed_ttc-predict(lm_clean_transformed, newdata=grid_Infarct_time_ttc, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Infarct_time_UCI_untransformed_ttc<-Infarct_time_predicted_untransformed_ttc+predict(lm_clean_transformed, newdata=grid_Infarct_time_ttc, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Infarct_time_predicted_ttc <- data.frame(grid_Infarct_time_ttc$Infarct_time, Infarct_time_predicted_untransformed_ttc^(1/Selected.lambda_clean), 
                                  Infarct_time_LCI_untransformed_ttc^(1/Selected.lambda_clean),
                                  Infarct_time_UCI_untransformed_ttc^(1/Selected.lambda_clean))

# Change the column names
colnames(df_Infarct_time_predicted_ttc)<-c("Time", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
#Infarct_time.correct_ttc<- df_Infarct_time_predicted_ttc[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 (of other histology, not ttc or mri)
df_Infarct_time_predicted_ttc$Infarct_volume<-df_Infarct_time_predicted_ttc$Infarct_volume-Infarct_time.correct_hist
df_Infarct_time_predicted_ttc$LCI<-df_Infarct_time_predicted_ttc$LCI-Infarct_time.correct_hist
df_Infarct_time_predicted_ttc$UCI<-df_Infarct_time_predicted_ttc$UCI-Infarct_time.correct_hist





#Combine all three predicted dataframes

#make new dataframes for edits
df_Infarct_time_predicted_hist_2 <- df_Infarct_time_predicted_hist
df_Infarct_time_predicted_ttc_2 <- df_Infarct_time_predicted_ttc
df_Infarct_time_predicted_mri_2 <- df_Infarct_time_predicted_mri

#add a category column to separate them
df_Infarct_time_predicted_hist_2$Category<-rep("Other histology", nrow(df_Infarct_time_predicted_hist_2)) 
df_Infarct_time_predicted_ttc_2$Category<-rep("TTC", nrow(df_Infarct_time_predicted_ttc_2)) 
df_Infarct_time_predicted_mri_2$Category<-rep("MRI", nrow(df_Infarct_time_predicted_mri_2)) 

#combine into one data frame
df_Infarct_time_x_method_predicted <- rbind(df_Infarct_time_predicted_hist_2,
                                                   df_Infarct_time_predicted_ttc_2,
                                                   df_Infarct_time_predicted_mri_2)

```

```{r Prediction plot_infarct_time_X_measurement_method, include=FALSE, eval=FALSE}
#convert infarct volume to percentage of average infarct
#convert time from hours to days
pdf("Continuous_predicted_infarct_time_x_method_1.pdf", width = 6, height = 4)
ggplot(df_Infarct_time_x_method_predicted, aes(x=(Time/24), 
                                               y=Infarct_volume*Expected_brain_vol_percent,
                                               group = Category), fill = Category) +
  geom_line(color="#292829", size=1) +
  geom_ribbon(aes(ymax=UCI*Expected_brain_vol_percent, 
                  ymin=LCI*Expected_brain_vol_percent, 
                  fill = Category),
              alpha=0.3) +
  scale_fill_manual(values = plasma(10)[c(1,4,7)])+
  geom_hline(yintercept=0, lty=2, size =1) +
  scale_x_continuous(breaks=seq(0,105,by=7)) +
  scale_y_continuous(breaks=seq(-125,175,by=25)) +
  theme_classic() +
  labs(x = "Time infarct was measured (days post stroke)", 
       y = "% of average infarct volume")+
  theme(axis.ticks=element_line(color="black", lineend = "square"), #Make ticks black
        ) 
dev.off()


```

# Posthoc analysis
Sex posthoc
```{r Sex post, include=FALSE, eval=FALSE}
#create reference grid for all variable combinations
Sex_LM = ref_grid(lm_clean_transformed, 
  non.nuisance = "Sex") #turns all variables into nuisance variables except one of interest
#Posthoc/Planned contrasts 
Sex_raw_posthoc <- lsmeans( #least squared means
  Sex_LM, pairwise ~ Sex, adjust="tukey")  #create best means for sex + pairwise comparisons + Tukey correction (can only be used if you do every possible comparison)

Sex_posthoc<-summary(Sex_raw_posthoc) #summarise

Sex_p_value<-data.frame(cbind(
  Sex_posthoc$contrasts[,-4])) #select columns we want
#View the table in a pretty way
tab_df(Sex_p_value,digits = 4,
  file = "Sex_posthoc_table_2.html")  #print results as html

```

Species posthoc
```{r Species post, include=FALSE, eval=FALSE}
Species_LM = ref_grid(lm_clean_transformed, 
  non.nuisance = "Animal")
#Posthoc/Planned contrasts 
Species_raw_posthoc <- lsmeans(
  Species_LM, pairwise ~ Animal, adjust="tukey") 
Species_posthoc<-summary(Species_raw_posthoc) 
 

Species_p_value<-data.frame(cbind(
  Species_posthoc$contrasts[,-4]))


#View the table in a pretty way
tab_df(Species_p_value,digits = 4,
  file = "Species_posthoc_table_2.html")  

#Species

```

Comorbitity posthoc
```{r Comorbitity post, include=FALSE, eval=FALSE}

Comorbidity_LM = ref_grid(lm_clean_transformed, 
  non.nuisance = "Comorbidity")
#Posthoc/Planned contrasts 
Comorbidity_raw_posthoc <- lsmeans(
  Comorbidity_LM, pairwise ~ Comorbidity, adjust="tukey") 

Comorbidity_posthoc<-summary(Comorbidity_raw_posthoc) 

Comorbidity_p_value<-data.frame(cbind(
  Comorbidity_posthoc$contrasts[,-4]))


#View the table in a pretty way
tab_df(Comorbidity_p_value,digits = 4,
  file = "Comorbidity_posthoc_table_2.html")  

#Comorbidity

```

Surigal level and infact measurement posthoc
```{r Surgical level and infact measurement, include=FALSE, eval=FALSE}
#ref grid of all possible comparisons
Surg_measure_LM = ref_grid(lm_clean_transformed, non.nuisance = c("Surgical_level", "Infarct_measurement"))
#Posthoc/Planned contrasts 
Surg_measure_raw_posthoc <- lsmeans(Surg_measure_LM, pairwise ~ Surgical_level*Infarct_measurement, adjust="none") #do posthocs with no corretions
Surg_measure_posthoc<-summary(Surg_measure_raw_posthoc) 

Surg_measure_p_value<-data.frame(cbind(Surg_measure_posthoc$contrasts["contrast"],Surg_measure_posthoc$contrasts["p.value"])) #table of the contrasts + unadjusted p-values

#Select the comparison you are interested in
Surg_measure_comparisons<-c(1,2,3,8,12,13,15,19,22,25,29,34,38,39,40,41,42,46,47,49,52,55,60,61,63,64,65,66)
Surg_measure_ptable<-Surg_measure_p_value[Surg_measure_comparisons,]

#Create a column of adjusted p values using the Holm-Sidak method - not taking every comparison so no tukey
Surg_measure_ptable$padj<-p.adjust(Surg_measure_ptable$p.value, method="holm") 

rownames(Surg_measure_ptable)<-1:nrow(Surg_measure_ptable) #rename rows

#View the table in a pretty way
tab_df(Surg_measure_ptable,digits = 4,file = "Surg_measure_posthoc_table_2.html", show.rownames = T)  

#Surg_measure

```

Anaesthetics posthoc
```{r Anaesthetic post, include=FALSE, eval=FALSE}
#list of all dummy variable column names
anaesthetics<-c("Isoflurane", "Ketamine", "Xylazine", "Nitrous_oxide", "Halothane", "Chloral_hydrate", "Sodium_pentobarbital", "Enflurane", "Tiletamine_Zolazepam", "Anaesthetic_not_reported", "Other_anaesthetics")
#loop time
#reset in case of other loops
i=1
j=1

Anaesthetics_ptable<-data.frame() #empty data frame

for (i in 1:(length(anaesthetics)-1)){ #-1 to stop one before the end as comparing to other list

  for (j in (i+1):length(anaesthetics)) { #start 1 from top with j to compare to anaesthetics i
   # make ref grid of pairwise comparisons - only the ones we want
    Anaesthetics_LM <-
      ref_grid(lm_clean_transformed, 
        non.nuisance = anaesthetics[c(i,j)]) #non nuisance variables are i-th + j-th anaesthetics
    #Posthoc/Planned contrasts 
    
    frmla <- as.formula(paste("pairwise", #generating the formula for the posthoc
      paste(anaesthetics[c(i,j)], 
        sep = "", collapse = " + "), sep = " ~ "))
    #regular code time
    Anaesthetics_raw_posthoc <-
      lsmeans(Anaesthetics_LM, #linear model with our reference grid
        frmla, adjust="none") #no adjustments yet

    Anaesthetics_posthoc<-summary(
      Anaesthetics_raw_posthoc) 
    
    Anaesthetics_p_value<-data.frame(cbind( #trim down some useless columns
      Anaesthetics_posthoc$contrasts["contrast"],
      Anaesthetics_posthoc$contrasts["p.value"]))
    
    #Select the comparison you are interested in
    Anaesthetics_comparisons<-c(4)
    if(nrow(Anaesthetics_ptable)==0){ #if nrows in anaesthetic table=0 
          Anaesthetics_ptable<- Anaesthetics_p_value[ #make the anaesthetic table equal results from posthoc
        Anaesthetics_comparisons,] #after initial table creation on first runthrough, tack new results on to end of table - this is because we didn't know how many comparisons there would be at the start
    } else{
        Anaesthetics_ptable<-rbind(
          Anaesthetics_ptable ,
          Anaesthetics_p_value[
            Anaesthetics_comparisons,])
      }
  }

}


#Create a column of adjusted p values using the Holm-Sidak method - not tukey as not all comparisons done
Anaesthetics_ptable$padj<-p.adjust(Anaesthetics_ptable$p.value, method="holm") 

rownames(Anaesthetics_ptable)<-1:nrow(Anaesthetics_ptable)

#View the table in a pretty way
tab_df(Anaesthetics_ptable,digits = 4,file = "Anaesthetics_posthoc_table_2.html", show.rownames = T)  

#Anaesthetics

```

Rose Bengal posthoc
```{r Rose bengal dose post, include=FALSE, eval=FALSE}

RB_dose_mgkg_cat_LM = ref_grid(lm_clean_transformed, non.nuisance = "RB_dose_mgkg_cat")
#Posthoc/Planned contrasts 
RB_dose_mgkg_cat_raw_posthoc <- lsmeans(RB_dose_mgkg_cat_LM, pairwise ~ RB_dose_mgkg_cat, adjust="none") 
RB_dose_mgkg_cat_posthoc<-summary(RB_dose_mgkg_cat_raw_posthoc) 


RB_dose_mgkg_cat_p_value<-data.frame(cbind(RB_dose_mgkg_cat_posthoc$contrasts["contrast"],RB_dose_mgkg_cat_posthoc$contrasts["p.value"]))

#Select the comparison you are interested in
RB_dose_mgkg_cat_comparisons<-c(1:6) #only take first 6 comparisons as only want compared to baseline
RB_dose_mgkg_cat_ptable<-RB_dose_mgkg_cat_p_value[RB_dose_mgkg_cat_comparisons,]

#Create a column of adjusted p values using the Holm-Sidak method - not tukey as comparing to just base
RB_dose_mgkg_cat_ptable$padj<-p.adjust(RB_dose_mgkg_cat_ptable$p.value, method="holm") 

#View the table in a pretty way
tab_df(RB_dose_mgkg_cat_ptable,digits = 4,file = "RB_dose_mgkg_cat_posthoc_table_2.html")  

#RB_dose_mgkg_cat

```

Light aperture posthoc
```{r light aperture post, include=FALSE, eval=FALSE}

Light_aperture_cat_LM = ref_grid(lm_clean_transformed, non.nuisance = "Light_aperture_cat")
#Posthoc/Planned contrasts 
Light_aperture_cat_raw_posthoc <- lsmeans(Light_aperture_cat_LM, pairwise ~ Light_aperture_cat, adjust="none") 
Light_aperture_cat_posthoc<-summary(Light_aperture_cat_raw_posthoc) 
  

Light_aperture_cat_p_value<-data.frame(cbind(Light_aperture_cat_posthoc$contrasts["contrast"],Light_aperture_cat_posthoc$contrasts["p.value"]))

#Select the comparison you are interested in
Light_aperture_cat_comparisons<-c(1:6)
Light_aperture_cat_ptable<-Light_aperture_cat_p_value[Light_aperture_cat_comparisons,]

#Create a column of adjusted p values using the Holm-Sidak method
Light_aperture_cat_ptable$padj<-p.adjust(Light_aperture_cat_ptable$p.value, method="holm") 

#View the table in a pretty way
tab_df(Light_aperture_cat_ptable,digits = 4,file = "Light_aperture_cat_posthoc_table_2.html")  

#Light_aperture_cat

```

Light time posthoc
```{r Light time post, include=FALSE, eval=FALSE}

Light_time_cat_LM = ref_grid(lm_clean_transformed, non.nuisance = "Light_time_cat")
#Posthoc/Planned contrasts 
Light_time_cat_raw_posthoc <- lsmeans(Light_time_cat_LM, pairwise ~ Light_time_cat, adjust="none") 
Light_time_cat_posthoc<-summary(Light_time_cat_raw_posthoc) 
Light_time_cat_p_value<-data.frame(cbind(Light_time_cat_posthoc$contrasts["contrast"],Light_time_cat_posthoc$contrasts["p.value"]))

#Select the comparison you are interested in
Light_time_cat_comparisons<-c(1:5)
Light_time_cat_ptable<-Light_time_cat_p_value[Light_time_cat_comparisons,]

#Create a column of adjusted p values using the Holm-Sidak method
Light_time_cat_ptable$padj<-p.adjust(Light_time_cat_ptable$p.value, method="holm") 

#View the table in a pretty way
tab_df(Light_time_cat_ptable,digits = 4,file = "Light_time_cat_posthoc_table_2.html")  

#Light_time_cat

```

Light source posthoc
```{r light source post, include=FALSE, eval=FALSE}
Light_source_LM = ref_grid(lm_clean_transformed, non.nuisance = "Light_source")
#Posthoc/Planned contrasts 

all =T
#if we want to do all comparisons, use tukey, if we don't, use Holm
if (all==T) {
    Light_source_raw_posthoc <- lsmeans(
      Light_source_LM, pairwise ~ 
        Light_source, adjust="tukey") 
    
    Light_source_posthoc<-summary(Light_source_raw_posthoc) 
    
    Light_source_p_value<-data.frame(cbind(
      Light_source_posthoc$contrasts[,-4]))

    #View the table in a pretty way
    tab_df(Light_source_p_value,digits = 4,
      file = "Light_source_posthoc_table_2.html")  
  } else {
    Light_source_raw_posthoc <- lsmeans(Light_source_LM,
      pairwise ~ Light_source, adjust="none") 
     Light_source_posthoc<-summary(Light_source_raw_posthoc) 
 
  
    Light_source_p_value<-data.frame(cbind(
      Light_source_posthoc$contrasts["contrast"],
      Light_source_posthoc$contrasts["p.value"]))
  
    #Select the comparison you are interested in
    Light_source_comparisons<-c(
      1:nrow(Light_source_p_value))
    Light_source_ptable<-Light_source_p_value[
      Light_source_comparisons,]
    
    #Create a column of adjusted p values using the Holm-Sidak method
    Light_source_ptable$padj<-p.adjust(
      Light_source_ptable$p.value, method="holm") 
    
    #View the table in a pretty way
    tab_df(Light_source_ptable,digits = 4,
      file = "Light_source_posthoc_table_2.html")  
}
#Light_source

```

Surgical level posthoc
```{r surgical level post, include=FALSE, eval=FALSE}
Surgical_level_LM = ref_grid(lm_clean_transformed, non.nuisance = "Surgical_level")
#Posthoc/Planned contrasts 

all =T

if (all==T) {
    Surgical_level_raw_posthoc <- lsmeans(
      Surgical_level_LM, pairwise ~ 
        Surgical_level, adjust="tukey") 
    
    Surgical_level_posthoc<-summary(Surgical_level_raw_posthoc) 
    
    Surgical_level_p_value<-data.frame(cbind(
      Surgical_level_posthoc$contrasts[,-4]))

    #View the table in a pretty way
    tab_df(Surgical_level_p_value,digits = 4,
      file = "Surgical_level_posthoc_table_2.html")  
  } else {
    Surgical_level_raw_posthoc <- lsmeans(Surgical_level_LM,
      pairwise ~ Surgical_level, adjust="none") 
     Surgical_level_posthoc<-summary(Surgical_level_raw_posthoc) 
 
  
    Surgical_level_p_value<-data.frame(cbind(
      Surgical_level_posthoc$contrasts["contrast"],
      Surgical_level_posthoc$contrasts["p.value"]))
  
    #Select the comparison you are interested in
    Surgical_level_comparisons<-c(
      1:nrow(Surgical_level_p_value))
    Surgical_level_ptable<-Surgical_level_p_value[
      Surgical_level_comparisons,]
    
    #Create a column of adjusted p values using the Holm-Sidak method
    Surgical_level_ptable$padj<-p.adjust(
      Surgical_level_ptable$p.value, method="holm") 
    
    #View the table in a pretty way
    tab_df(Surgical_level_ptable,digits = 4,
      file = "Surgical_level_posthoc_table_2.html")  
}
#Surgical_level


```

Infarct measurement level posthoc
```{r Infarct measurement level post, include=FALSE, eval=FALSE}
Infarct_measurement_LM = ref_grid(lm_clean_transformed, non.nuisance = "Infarct_measurement")
#Posthoc/Planned contrasts 

all =T

if (all==T) {
    Infarct_measurement_raw_posthoc <- lsmeans(
      Infarct_measurement_LM, pairwise ~ 
        Infarct_measurement, adjust="tukey") 
    
    Infarct_measurement_posthoc<-summary(Infarct_measurement_raw_posthoc) 
    
    Infarct_measurement_p_value<-data.frame(cbind(
      Infarct_measurement_posthoc$contrasts[,-4]))

    #View the table in a pretty way
    tab_df(Infarct_measurement_p_value,digits = 4,
      file = "Infarct_measurement_posthoc_table_2.html")  
  } else {
    Infarct_measurement_raw_posthoc <- lsmeans(Infarct_measurement_LM,
      pairwise ~ Infarct_measurement, adjust="none") 
     Infarct_measurement_posthoc<-summary(Infarct_measurement_raw_posthoc) 
 
  
    Infarct_measurement_p_value<-data.frame(cbind(
      Infarct_measurement_posthoc$contrasts["contrast"],
      Infarct_measurement_posthoc$contrasts["p.value"]))
  
    #Select the comparison you are interested in
    Infarct_measurement_comparisons<-c(
      1:nrow(Infarct_measurement_p_value))
    Infarct_measurement_ptable<-Infarct_measurement_p_value[
      Infarct_measurement_comparisons,]
    
    #Create a column of adjusted p values using the Holm-Sidak method
    Infarct_measurement_ptable$padj<-p.adjust(
      Infarct_measurement_ptable$p.value, method="holm") 
    
    #View the table in a pretty way
    tab_df(Infarct_measurement_ptable,digits = 4,
      file = "Infarct_measurement_posthoc_table_2.html")  
}
#Infarct_measurement


```



# New linear models for small continuous variables

Dataframes and variable editing for wavelength and intensity
```{r Dataframes_wavelength_intensity_surgical*aperture, include=FALSE}
#create dataframes with only complete variables of interest (remove rows with NA's)

# Wavelength
dfc3_Wavelength <- dfc3_Models_clean %>%
  filter(!is.na(dfc3_Models_clean$Light_wavelength))
#end up with 247 rows, down from 416
dfc3_Wavelength <- dfc3_Wavelength[dfc3_Wavelength$Light_wavelength!=473,] #remove two studies with 473nm wavelength, they are heavily skewing the predictions and their brain volume results are dubious

# Intensity
dfc3_Intensity <- dfc3_Models_clean %>%
  filter(!is.na(dfc3_Models_clean$Light_intensity_Wcm2))
# end up with 92 rows, down from 416

# Light skull penetration
dfc3_Surgical_Aperture <- dfc3_Models_clean %>%
  filter(!is.na(dfc3_Models_clean$Light_aperture)) 
# end up with 305 rows down from 416
dfc3_Surgical_Aperture <- dfc3_Surgical_Aperture %>%
  filter(!is.na(dfc3_Surgical_Aperture$Light_wavelength))
# end up with 169 rows down from 305
dfc3_Surgical_Aperture <- dfc3_Surgical_Aperture[dfc3_Surgical_Aperture$Light_wavelength!=473,] #remove two studies with 473nm wavelength, they are heavily skewing the predictions and their brain volume results are dubious
# end up with 167 rows down from 169
dfc3_Surgical_Aperture <- droplevels(dfc3_Surgical_Aperture[!dfc3_Surgical_Aperture$Infarct_measurement == "MRI (in vivo)", ])
dfc3_Surgical_Aperture <- droplevels(dfc3_Surgical_Aperture[!dfc3_Surgical_Aperture$Animal == "Other", ])
dfc3_Surgical_Aperture <- droplevels(dfc3_Surgical_Aperture[!dfc3_Surgical_Aperture$Surgical_level == "Skull thinned", ])
dfc3_Surgical_Aperture <- droplevels(dfc3_Surgical_Aperture[!dfc3_Surgical_Aperture$Surgical_level == "Other", ])
#rows down to 125 out of 169

```

```{r Check_small_variables_wavelength_intensity_surgery*aperture, include=FALSE}
#check if any factors have fewer than 8 instances, if there are no issues, prints "TRUE", if I need to check that variable, prints "FALSE"

#list the columns of interest
Model_col_names <- c("Sex",
     "Infarct_measurement",
     "Surgical_level",
     "Comorbidity",
     "Isoflurane",
     "Ketamine",
     "Xylazine",
     "Nitrous_oxide",
     "Halothane",
     "Chloral_hydrate",
     "Sodium_pentobarbital",
     "Enflurane",
     "Tiletamine_Zolazepam",
     "Anaesthetic_not_reported",
     "Other_anaesthetics",
     "RB_dose_mgkg_cat",
     "Light_source",
     "Light_aperture_cat",
     "Light_time_cat")

#check wavelength dataset
Min_n_wavelength <- rep("NA", length(Model_col_names)) #make a list of correct length, fill with NA's

for(i in 1:length(Model_col_names)){

Min_n_wavelength[i] <- min(summary(as.factor(dfc3_Wavelength[ , Model_col_names[i]])))>=8
#for each row in min_n list, on round 1 check if minimum is less than 8 for column 1, then repeat
}
tab_df(data.frame(Model_col_names, Min_n_wavelength)) #print out results


#repeat for light intensity
Min_n_intensity <- rep("NA", length(Model_col_names)) #make a list of correct length, fill with NA's

for(i in 1:length(Model_col_names)){

Min_n_intensity[i] <- min(summary(as.factor(dfc3_Intensity[ , Model_col_names[i]])))>=8
#for each row in min_n list, on round 1 check if minimum is less than 8 for column 1, then repeat
}
tab_df(data.frame(Model_col_names, Min_n_intensity)) #print out results


#check surgery*aperture dataset
Min_n_Surgical_Aperture <- rep("NA", length(Model_col_names)) #make a list of correct length, fill with NA's

for(i in 1:length(Model_col_names)){

Min_n_Surgical_Aperture[i] <- min(summary(as.factor(dfc3_Surgical_Aperture[ , Model_col_names[i]])))>=8
#for each row in min_n list, on round 1 check if minimum is less than 8 for column 1, then repeat
}
tab_df(data.frame(Model_col_names, Min_n_Surgical_Aperture)) #print out results


```

```{r remove_small_variables_wavelength_intensity_surgery*aperture, include=FALSE}
# for wavelength, check: Comorbidity, Tiletamine_Zolazepam, Anaesthetic_not_reported, Other_anaesthetics, RB_dose_mgkg_cat, Light_source, Light_aperture_cat

summary(as.factor(dfc3_Wavelength$Comorbidity)) # remove other - leaves only 3 groups, one of which has 8 instances - remove entire factor from model as it's non-signif in main model
summary(as.factor(dfc3_Wavelength$Tiletamine_Zolazepam)) # remove entire factor from model
summary(as.factor(dfc3_Wavelength$Anaesthetic_not_reported)) # remove entire factor from model
summary(as.factor(dfc3_Wavelength$Other_anaesthetics)) # remove entire factor from model
summary(as.factor(dfc3_Wavelength$RB_dose_mgkg_cat)) # two factors need removing, would destroy the order of doses, removing entire factor from model

summary(as.factor(dfc3_Wavelength$Light_source)) # reclassify LED and Cold light (unspecified) to Other
  levels(dfc3_Wavelength$Light_source)[levels(dfc3_Wavelength$Light_source)=="LED"] <- "Other" 
  levels(dfc3_Wavelength$Light_source)[levels(dfc3_Wavelength$Light_source)=="Cold light (unspecified)"] <- "Other" 
  
summary(as.factor(dfc3_Wavelength$Light_aperture_cat)) # remove, 3-5mm, 4-5mm, 5+mm - change to 3mm+
  levels(dfc3_Wavelength$Light_aperture_cat)[levels(dfc3_Wavelength$Light_aperture_cat)=="3-4mm"] <- "3+mm" 
  levels(dfc3_Wavelength$Light_aperture_cat)[levels(dfc3_Wavelength$Light_aperture_cat)=="4-5mm"] <- "3+mm" 
  levels(dfc3_Wavelength$Light_aperture_cat)[levels(dfc3_Wavelength$Light_aperture_cat)=="5+mm"] <- "3+mm" 
  


#for intensity check: Sex, Surgical_level, Comorbidity, Ketamine, Xylazine, Enflurane, Tiletamine_Zolazepam, Anaesthetic_not_reported, RB_dose_mgkg_cat, Light_source, Light_aperture_cat, Light_time_cat

summary(as.factor(dfc3_Intensity$Sex)) # female + mixed are gone, NR has 10 but remove whole factor at this point
summary(as.factor(dfc3_Intensity$Surgical_level)) # skull thinned + other to go, remove whole factor at this point
summary(as.factor(dfc3_Intensity$Comorbidity)) # remove entire factor, only one group remains
summary(as.factor(dfc3_Intensity$Ketamine)) # remove entire factor from model
summary(as.factor(dfc3_Intensity$Xylazine)) # remove entire factor from model
summary(as.factor(dfc3_Intensity$Enflurane)) # remove entire factor from model
summary(as.factor(dfc3_Intensity$Tiletamine_Zolazepam)) # remove entire factor from model
summary(as.factor(dfc3_Intensity$Anaesthetic_not_reported)) # remove entire factor from model
summary(as.factor(dfc3_Intensity$RB_dose_mgkg_cat))  # three groups need removing, leaving only 3 (and not in order of dose), remove entire factor from model
summary(as.factor(dfc3_Intensity$Light_source)) # remove Krypton laser, Diode laser (unspecified), Cold light (unspecified), LED, reclassify as Other
  levels(dfc3_Intensity$Light_source)[levels(dfc3_Intensity$Light_source)=="Krypton laser"] <- "Other" 
  levels(dfc3_Intensity$Light_source)[levels(dfc3_Intensity$Light_source)=="Diode laser (unspecified)"] <- "Other"
  levels(dfc3_Intensity$Light_source)[levels(dfc3_Intensity$Light_source)=="Cold light (unspecified)"] <- "Other"
  levels(dfc3_Intensity$Light_source)[levels(dfc3_Intensity$Light_source)=="LED"] <- "Other"
  
summary(as.factor(dfc3_Intensity$Light_aperture_cat)) # remove, 3-5mm, 4-5mm, 5+mm - change to 3mm+
  levels(dfc3_Intensity$Light_aperture_cat)[levels(dfc3_Intensity$Light_aperture_cat)=="3-4mm"] <- "3+mm" 
  levels(dfc3_Intensity$Light_aperture_cat)[levels(dfc3_Intensity$Light_aperture_cat)=="4-5mm"] <- "3+mm" 
  levels(dfc3_Intensity$Light_aperture_cat)[levels(dfc3_Intensity$Light_aperture_cat)=="5+mm"] <- "3+mm" 
  
summary(as.factor(dfc3_Intensity$Light_time_cat)) #only one to remove is not reported - one case - will have to delete a row for this
  dfc3_Intensity <- droplevels(dfc3_Intensity[!dfc3_Intensity$Light_time_cat == "Not reported", ])
  #dropped down to 91 observations now

# For Surgery*aperture, keep only rows with large variable groups for surgery, infarct measurement, and animal

# dfc3_Surgical_Aperture<-dfc3_Surgical_Aperture[dfc3_Surgical_Aperture$Surgical_level=="Scalp retracted, skull intact"|
#                                                  dfc3_Surgical_Aperture$Surgical_level=="Skull breached",]

# dfc3_Surgical_Aperture<-dfc3_Surgical_Aperture[dfc3_Surgical_Aperture$Infarct_measurement=="TTC (ex vivo)"|
#                                                  dfc3_Surgical_Aperture$Infarct_measurement=="Other histology (ex vivo)",]

# dfc3_Surgical_Aperture<-dfc3_Surgical_Aperture[dfc3_Surgical_Aperture$Animal=="Rat"|
#                                                  dfc3_Surgical_Aperture$Animal=="Mouse",]


#check sex, comorbidity, anaesthetics from Tiletamine onwards (don't need to check as cutting anaesthetics from model), RB_dose_mgkg_cat, Light_time_cat (Light_aperture_cat not needed as using numeric aperture)
summary(dfc3_Surgical_Aperture$Sex) #female has 4, mixed has 6, NR has nine. Cut from model, not enough to calculate
summary(dfc3_Surgical_Aperture$Comorbidity) # Aged has 5, Other has only 4, leaves only noe + hypertension so removing from model
summary(dfc3_Surgical_Aperture$RB_dose_mgkg_cat) # 60-75mg/kg has only 1, 30-45 has 4, 75+ has 4 - combining top 4 dose groups into one "30+mg/kg"
  levels(dfc3_Surgical_Aperture$RB_dose_mgkg_cat)[levels(dfc3_Surgical_Aperture$RB_dose_mgkg_cat)=="30-45mg/kg"] <- "30+mg/kg" 
  levels(dfc3_Surgical_Aperture$RB_dose_mgkg_cat)[levels(dfc3_Surgical_Aperture$RB_dose_mgkg_cat)=="45-60mg/kg"] <- "30+mg/kg" 
  levels(dfc3_Surgical_Aperture$RB_dose_mgkg_cat)[levels(dfc3_Surgical_Aperture$RB_dose_mgkg_cat)=="60-75mg/kg"] <- "30+mg/kg"
  levels(dfc3_Surgical_Aperture$RB_dose_mgkg_cat)[levels(dfc3_Surgical_Aperture$RB_dose_mgkg_cat)=="75+mg/kg"] <- "30+mg/kg"
  
summary(dfc3_Surgical_Aperture$Light_time_cat) # Not reported has 2, 15-20 mins has 5, removing NR and collapsing 15-20mins and 20+ into 15+mins
  dfc3_Surgical_Aperture <- droplevels(dfc3_Surgical_Aperture[!dfc3_Surgical_Aperture$Light_time_cat == "Not reported", ])
  levels(dfc3_Surgical_Aperture$Light_time_cat)[levels(dfc3_Surgical_Aperture$Light_time_cat)=="15-20mins"] <- "15+mins"
  levels(dfc3_Surgical_Aperture$Light_time_cat)[levels(dfc3_Surgical_Aperture$Light_time_cat)=="20+mins"] <- "15+mins"
#for some reason model errors when this is left in and can't run, may have to remove from model entirely - might be due to over complexity of model maening we have rank deficiencies?
  
# down to 123 rows

# table(dfc3_Surgical_Aperture$Light_time_cat, dfc3_Surgical_Aperture$Surgical_level, dfc3_Surgical_Aperture$Animal, dfc3_Surgical_Aperture$Infarct_measurement) # checking to find why model is erroring with light time, some of these groups have 0 instances of these combinations, may be our issue?
  
```


Models for wavelength and intensity and Surgical*Aperture
```{r Model_wavelength}
# Model using only data which has a value for wavelength, making wavelength a continuous variable again
#linear model with all cleaned variables + one outlier removed
lm_wavelength <- lm(data = dfc3_Wavelength,
   Infarct_percent_control ~
     Animal +
     Sex +
     Infarct_time + #this is numeric with 16 NA's
     Infarct_measurement +
     Infarct_measurement*Surgical_level + #interaction
     Surgical_level +
     #Comorbidity + # removed due to small factor numbers, see above chunk
     Isoflurane + #dummy
     Ketamine + #dummy
     Xylazine + #dummy
     Nitrous_oxide + #dummy
     Halothane + #dummy
     Chloral_hydrate + #dummy
     Sodium_pentobarbital + #dummy
     #Enflurane + #dummy # model is rank deficient when keeping this in
     #Tiletamine_Zolazepam + #dummy # removed due to small factor numbers, see above chunk
     #Anaesthetic_not_reported + #dummy # removed due to small factor numbers, see above chunk
     #Other_anaesthetics + # removed due to small factor numbers, see above chunk
     #RB_dose_mgkg_cat + # removed due to small factor numbers, see above chunk
     Light_source +
     Light_aperture_cat +
     Light_time_cat + 
     Light_wavelength,
   weights = N_animals_control
   )

#BoxCox transformation of this model
lm_boxcox_wavelength<-boxcox(lm_wavelength,lambda = seq(-5, 5, 1/1000), plotit = TRUE)

Selected.lambda_wavelength <-lm_boxcox_wavelength$x[lm_boxcox_wavelength$y==max(lm_boxcox_wavelength$y)] 
Selected.lambda_wavelength

#Run the transformed model
lm_wavelength_transformed <- lm(data = dfc3_Wavelength,
   Infarct_percent_control^Selected.lambda_wavelength  ~ #transformed dependent variable
     Animal +
     Sex +
     Infarct_time + #this is numeric with 16 NA's
     Infarct_measurement +
     Infarct_measurement*Surgical_level + #interaction
     Surgical_level +
     #Comorbidity + # removed due to small factor numbers, see above chunk
     Isoflurane + #dummy
     Ketamine + #dummy
     Xylazine + #dummy
     Nitrous_oxide + #dummy
     Halothane + #dummy
     Chloral_hydrate + #dummy
     Sodium_pentobarbital + #dummy
     #Enflurane + #dummy # model is rank deficient when keeping this in
     #Tiletamine_Zolazepam + #dummy # removed due to small factor numbers, see above chunk
     #Anaesthetic_not_reported + #dummy # removed due to small factor numbers, see above chunk
     #Other_anaesthetics + # removed due to small factor numbers, see above chunk
     #RB_dose_mgkg_cat + # removed due to small factor numbers, see above chunk
     Light_source +
     Light_aperture_cat +
     Light_time_cat+ #numeric with 15 NA's, changed to categorical
     Light_wavelength,
   weights = N_animals_control
   )

summary(lm_wavelength_transformed) #this is type 3 - order doesn't matter


tab_model(lm_wavelength_transformed,
  file = "lm_wavelength_transformed_full_model_2.html", digits = 4)  #print results as html

tab_df(car::Anova(lm_wavelength_transformed), show.rownames = TRUE,
  file = "lm_wavelength_transformed_ANOVA_model_2.html", digits = 4) #this is type 3 - order doesn't matter
```

```{r Model_wavelength_quadratic, include=FALSE, eval=FALSE}
#model again but quadratic to give it more freedom to plot a non-linear relationship
#theorised perhaps the relationship was non-linear, going up in the 500nm wavelength zone then back down at smaller/larger wavelengths. After assessing this model and the output table, it seems we don't have enough wavelengths smaller than 500nm to properly model this, so in the final analysis we went with the linear relationship instead. Have kept this code as legacy anyway.

# Model using only data which has a value for wavelength, making wavelength a continuous variable again
#linear model with all cleaned variables + one outlier removed
lm_wavelength_q <- lm(data = dfc3_Wavelength,
   Infarct_percent_control ~
     Animal +
     Sex +
     Infarct_time + #this is numeric with 16 NA's
     Infarct_measurement +
     Infarct_measurement*Surgical_level + #interaction
     Surgical_level +
     #Comorbidity + # removed due to small factor numbers, see above chunk
     Isoflurane + #dummy
     Ketamine + #dummy
     Xylazine + #dummy
     Nitrous_oxide + #dummy
     Halothane + #dummy
     Chloral_hydrate + #dummy
     Sodium_pentobarbital + #dummy
     Enflurane + #dummy
     #Tiletamine_Zolazepam + #dummy # removed due to small factor numbers, see above chunk
     #Anaesthetic_not_reported + #dummy # removed due to small factor numbers, see above chunk
     #Other_anaesthetics + # removed due to small factor numbers, see above chunk
     #RB_dose_mgkg_cat + # removed due to small factor numbers, see above chunk
     Light_source +
     Light_aperture_cat +
     Light_time_cat + 
     poly(Light_wavelength,2), #add squared version of variable of interest
   weights = N_animals_control
   )


#BoxCox transformation of this model
lm_boxcox_wavelength_q<-boxcox(lm_wavelength_q,lambda = seq(-5, 5, 1/1000), plotit = TRUE)

Selected.lambda_wavelength_q <-lm_boxcox_wavelength_q$x[lm_boxcox_wavelength_q$y==max(lm_boxcox_wavelength_q$y)] 
Selected.lambda_wavelength_q

#Run the transformed model
lm_wavelength_transformed_q <- lm(data = dfc3_Wavelength,
   Infarct_percent_control^Selected.lambda_wavelength_q  ~ #transformed dependent variable
     Animal +
     Sex +
     Infarct_time + #this is numeric with 16 NA's
     Infarct_measurement +
     Infarct_measurement*Surgical_level + #interaction
     Surgical_level +
     #Comorbidity + # removed due to small factor numbers, see above chunk
     Isoflurane + #dummy
     Ketamine + #dummy
     Xylazine + #dummy
     Nitrous_oxide + #dummy
     Halothane + #dummy
     Chloral_hydrate + #dummy
     Sodium_pentobarbital + #dummy
     Enflurane + #dummy
     #Tiletamine_Zolazepam + #dummy # removed due to small factor numbers, see above chunk
     #Anaesthetic_not_reported + #dummy # removed due to small factor numbers, see above chunk
     #Other_anaesthetics + # removed due to small factor numbers, see above chunk
     #RB_dose_mgkg_cat + # removed due to small factor numbers, see above chunk
     Light_source +
     Light_aperture_cat +
     Light_time_cat+ #numeric with 15 NA's, changed to categorical
     poly(Light_wavelength,2), #add squared version of variable of interest,
   weights = N_animals_control
   )

summary(lm_wavelength_transformed_q) #this is type 3 - order doesn't matter

tab_model(lm_wavelength_transformed_q)

tab_df(car::Anova(lm_wavelength_transformed_q), show.rownames = TRUE) #this is type 3 - order doesn't matter
```

```{r Model_intensity}
# Model using only data which has a value for wavelength, making wavelength a continuous variable again
#linear model with all cleaned variables + one outlier removed
lm_intensity <- lm(data = dfc3_Intensity,
   Infarct_percent_control ~
     Animal +
     #Sex + # removed due to small factor numbers, see above chunk
     Infarct_time + #this is numeric with 16 NA's
     Infarct_measurement +
     #Infarct_measurement*Surgical_level + #interaction # removed due to small factor numbers, see above chunk
     #Surgical_level + # removed due to small factor numbers, see above chunk
     #Comorbidity + # removed due to small factor numbers, see above chunk
     Isoflurane + #dummy
     #Ketamine + #dummy # removed due to small factor numbers, see above chunk
     #Xylazine + #dummy # removed due to small factor numbers, see above chunk
     Nitrous_oxide + #dummy
     Halothane + #dummy
     Chloral_hydrate + #dummy
     Sodium_pentobarbital + #dummy
     #Enflurane + #dummy # removed due to small factor numbers, see above chunk
     #Tiletamine_Zolazepam + #dummy # removed due to small factor numbers, see above chunk
     #Anaesthetic_not_reported + #dummy # removed due to small factor numbers, see above chunk
     Other_anaesthetics +
     #RB_dose_mgkg_cat + # removed due to small factor numbers, see above chunk
     Light_source +
     Light_aperture_cat +
     Light_time_cat + 
     Light_intensity_Wcm2 +
     Light_intensity_Wcm2*Light_aperture_cat, 
   weights = N_animals_control
   )

#BoxCox transformation of this model
lm_boxcox_intensity<-boxcox(lm_intensity,lambda = seq(-5, 5, 1/1000), plotit = TRUE)

Selected.lambda_intensity <-lm_boxcox_intensity$x[lm_boxcox_intensity$y==max(lm_boxcox_intensity$y)] 
Selected.lambda_intensity

#Run the transformed model
lm_intensity_transformed <- lm(data = dfc3_Intensity,
   Infarct_percent_control^Selected.lambda_intensity  ~ #transformed dependent variable
     Animal +
     #Sex + # removed due to small factor numbers, see above chunk
     Infarct_time + #this is numeric with 16 NA's
     Infarct_measurement +
     #Infarct_measurement*Surgical_level + #interaction # removed due to small factor numbers, see above chunk
     #Surgical_level + # removed due to small factor numbers, see above chunk
     #Comorbidity + # removed due to small factor numbers, see above chunk
     Isoflurane + #dummy
     #Ketamine + #dummy # removed due to small factor numbers, see above chunk
     #Xylazine + #dummy # removed due to small factor numbers, see above chunk
     Nitrous_oxide + #dummy
     Halothane + #dummy
     Chloral_hydrate + #dummy
     Sodium_pentobarbital + #dummy
     #Enflurane + #dummy # removed due to small factor numbers, see above chunk
     #Tiletamine_Zolazepam + #dummy # removed due to small factor numbers, see above chunk
     #Anaesthetic_not_reported + #dummy # removed due to small factor numbers, see above chunk
     Other_anaesthetics +
     #RB_dose_mgkg_cat + # removed due to small factor numbers, see above chunk
     Light_source +
     Light_aperture_cat +
     Light_time_cat+ #numeric with 15 NA's, changed to categorical
     Light_intensity_Wcm2 +
     Light_intensity_Wcm2*Light_aperture_cat,
   weights = N_animals_control
   )

summary(lm_intensity_transformed) #this is type 3 - order doesn't matter

tab_model(lm_intensity_transformed,
  file = "lm_intensity_transformed_full_model_2.html", digits = 4)

tab_df(car::Anova(lm_intensity_transformed), show.rownames = TRUE,
  file = "lm_intensity_transformed_ANOVA_model_2.html", digits = 4) #this is type 3 - order doesn't matter

```

```{r model_surgery_and_aperture}

# Repeat for Surgical level * Aperture
# 167 observations make it through this model

lm_Surgical_Aperture <- lm(data = dfc3_Surgical_Aperture,
   Infarct_percent_control ~
     Animal +
     #Sex + # removed from model due to low numbers in 3/4 groups, see above code
     Infarct_time + #this is numeric with 16 NA's
     Infarct_measurement +
     #Infarct_measurement*Surgical_level + # not interaction of interest in this model
     Surgical_level +
     #Comorbidity + # removed from model due to low numbers in 2/4 groups, see above code
     # Isoflurane + #dummy # removed due to no significance in any previous models
     # Ketamine + #dummy # removed due to no significance in any previous models
     # Xylazine + #dummy # removed due to no significance in any previous models
     # Nitrous_oxide + #dummy # removed due to no significance in any previous models
     # Halothane + #dummy # removed due to no significance in any previous models
     # Chloral_hydrate + #dummy # removed due to no significance in any previous models
     # Sodium_pentobarbital + #dummy # removed due to no significance in any previous models
     # Enflurane + #dummy # removed due to no significance in any previous models
     # Tiletamine_Zolazepam + #dummy # removed due to no significance in any previous models
     # Anaesthetic_not_reported + #dummy # removed due to no significance in any previous models
     # Other_anaesthetics + # removed due to no significance in any previous models
     Light_source +
     Light_aperture*Surgical_level + # interaction of interest
     #Light_time_cat, + # for some reason model errors when this is left in, I can't find why
     Light_wavelength, #kept as continuous + included as we care about light parameters
   weights = N_animals_control
   )

#BoxCox transformation of this model
lm_Surgical_Aperture<-boxcox(lm_Surgical_Aperture,lambda = seq(-5, 5, 1/1000), plotit = TRUE)

Selected.lambda_Surgical_Aperture <-lm_Surgical_Aperture$x[lm_Surgical_Aperture$y==max(lm_Surgical_Aperture$y)] 
Selected.lambda_Surgical_Aperture

#Run the transformed model
lm_Surgical_Aperture_Transformed <- lm(data = dfc3_Surgical_Aperture,
   Infarct_percent_control^Selected.lambda_Surgical_Aperture ~
     Animal +
     #Sex + # removed from model due to low numbers in 3/4 groups, see above code
     Infarct_time + #this is numeric with 16 NA's
     Infarct_measurement +
     #Infarct_measurement*Surgical_level + # not interaction of interest in this model
     Surgical_level +
     #Comorbidity + # removed from model due to low numbers in 2/4 groups, see above code
     # Isoflurane + #dummy # removed due to no significance in any previous models
     # Ketamine + #dummy # removed due to no significance in any previous models
     # Xylazine + #dummy # removed due to no significance in any previous models
     # Nitrous_oxide + #dummy # removed due to no significance in any previous models
     # Halothane + #dummy # removed due to no significance in any previous models
     # Chloral_hydrate + #dummy # removed due to no significance in any previous models
     # Sodium_pentobarbital + #dummy # removed due to no significance in any previous models
     # Enflurane + #dummy # removed due to no significance in any previous models
     # Tiletamine_Zolazepam + #dummy # removed due to no significance in any previous models
     # Anaesthetic_not_reported + #dummy # removed due to no significance in any previous models
     # Other_anaesthetics + # removed due to no significance in any previous models
     Light_source +
     Light_aperture*Surgical_level + # interaction of interest
     #Light_time_cat, + # for some reason model errors when this is left in, I can't find why
     Light_wavelength, #kept as continuous + included as we care about light parameters
   weights = N_animals_control)

summary(lm_Surgical_Aperture_Transformed) #this is type 3 - order doesn't matter

tab_model(lm_Surgical_Aperture_Transformed,
  file = "lm_surgery_aperture_transformed_full_model_2.html", digits = 4)

tab_df(car::Anova(lm_Surgical_Aperture_Transformed), show.rownames = TRUE,
  file = "lm_surgery_aperture_transformed_ANOVA_model_2.html", digits = 4) #this is type 3 - order doesn't matter
```


Prediction plots for wavelength and intensity and Surgical*Aperture
```{r Dataframe_prediction_plot_wavelength, include=FALSE}

#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Wavelength<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, # start at 4 hours (lowest), go up to 720 (not highest but this is 30 days post-stroke) in 4 hour increments
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     #Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     Enflurane =0, #dummy
     #Tiletamine_Zolazepam =0, #dummy
     #Anaesthetic_not_reported =0, #dummy
     #Other_anaesthetics =0,
     #RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
     Light_wavelength = seq(515, 800, by=5), # start at 473nm (lowest is 473), go up to 800nm in 5nm increments
   weights = 8) #average n of animals = ~8

summary(dfc3_Wavelength$Light_wavelength)
hist(dfc3_Wavelength$Light_wavelength)

# generate predicted values from our model
Wavelength_predicted_untransformed <- predict(lm_wavelength_transformed, 
                                              newdata=grid_Wavelength)
# generate lower confidence intervals by subtracting standard errors
Wavelength_LCI_untransformed <- Wavelength_predicted_untransformed-predict(lm_wavelength_transformed, 
                                                                           newdata=grid_Wavelength, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Wavelength_UCI_untransformed<-Wavelength_predicted_untransformed+predict(lm_wavelength_transformed, 
                                                                         newdata=grid_Wavelength, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Wavelength_predicted <- data.frame(grid_Wavelength$Light_wavelength, 
                                      Wavelength_predicted_untransformed^(1/Selected.lambda_wavelength),
                                      Wavelength_LCI_untransformed^(1/Selected.lambda_wavelength),
                                      Wavelength_UCI_untransformed^(1/Selected.lambda_wavelength))

# Change the column names
colnames(df_Wavelength_predicted)<-c("Wavelength", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
Wavelength.correct<- df_Wavelength_predicted[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Wavelength_predicted$Infarct_volume<-df_Wavelength_predicted$Infarct_volume-Wavelength.correct
df_Wavelength_predicted$LCI<-df_Wavelength_predicted$LCI-Wavelength.correct
df_Wavelength_predicted$UCI<-df_Wavelength_predicted$UCI-Wavelength.correct


```

```{r Prediction_plot_wavelength, include=FALSE, eval=FALSE}

pdf("Continuous_predicted_wavelength_3.pdf", width = 4.5, height = 4)
ggplot(df_Wavelength_predicted, aes(x=Wavelength, y=Infarct_volume*Expected_brain_vol_percent)) +
  geom_ribbon(aes(ymax=UCI*Expected_brain_vol_percent, ymin=LCI*Expected_brain_vol_percent), 
              alpha=0.3,
              fill=plasma(4)[2]) +
  geom_line(color="#292829", size=1) +
  geom_hline(yintercept=0, lty=2, size =1) +
  scale_x_continuous(breaks=seq(450,800,by=50), limits = c(450,800)) +
  scale_y_continuous(breaks=seq(-100,100,by=20)) +
  theme_classic() +
  labs(x = "Light wavelength (nm)",
       y = "% of average infarct volume")+
  theme(axis.ticks=element_line(color="black", lineend = "square"), #Make ticks black
        )
dev.off()


```

```{r Dataframe_prediction_plot_wavelength_quadratic, include=FALSE, eval=FALSE}
#theorised perhaps the relationship was non-linear, going up in the 500nm wavelength zone then back down at smaller/larger wavelengths. After assessing this model and the output table, it seems we don't have enough wavelengths smaller than 500nm to properly model this, so in the final analysis we went with the linear relationship instead. Have kept this code as legacy anyway.

#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Wavelength_q<-expand.grid(Animal = "Rat",
     Sex ="Male",
     Infarct_time =  24, # start at 4 hours (lowest), go up to 720 (not highest but this is 30 days post-stroke) in 4 hour increments
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = 'Scalp retracted, skull intact',
     #Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     Ketamine = 0, #dummy
     Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     Enflurane =0, #dummy
     #Tiletamine_Zolazepam =0, #dummy
     #Anaesthetic_not_reported =0, #dummy
     #Other_anaesthetics =0,
     #RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
     Light_wavelength = seq(515, 800, by=5), # start at 473nm (lowest is 473), go up to 800nm in 5nm increments
   weights = 8) #average n of animals = ~8


# generate predicted values from our model
Wavelength_predicted_untransformed_q <- predict(lm_wavelength_transformed_q, 
                                              newdata=grid_Wavelength_q)
# generate lower confidence intervals by subtracting standard errors
Wavelength_LCI_untransformed_q <- Wavelength_predicted_untransformed_q-predict(lm_wavelength_transformed_q, 
                                                                           newdata=grid_Wavelength_q, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Wavelength_UCI_untransformed_q<-Wavelength_predicted_untransformed_q+predict(lm_wavelength_transformed_q, 
                                                                         newdata=grid_Wavelength_q, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Wavelength_predicted_q <- data.frame(grid_Wavelength_q$Light_wavelength, 
                                      Wavelength_predicted_untransformed_q^(1/Selected.lambda_wavelength_q),
                                      Wavelength_LCI_untransformed_q^(1/Selected.lambda_wavelength_q),
                                      Wavelength_UCI_untransformed_q^(1/Selected.lambda_wavelength_q))

# Change the column names
colnames(df_Wavelength_predicted_q)<-c("Wavelength", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
Wavelength.correct_q<- df_Wavelength_predicted_q[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Wavelength_predicted_q$Infarct_volume<-df_Wavelength_predicted_q$Infarct_volume-Wavelength.correct_q
df_Wavelength_predicted_q$LCI<-df_Wavelength_predicted_q$LCI-Wavelength.correct_q
df_Wavelength_predicted_q$UCI<-df_Wavelength_predicted_q$UCI-Wavelength.correct_q


```

```{r Prediction_plot_wavelength_quadratic, include=FALSE, eval=FALSE}

pdf("Continuous_predicted_wavelength_quadratic_2.pdf", width = 8, height = 6)
ggplot(df_Wavelength_predicted_q, aes(x=Wavelength, y=Infarct_volume*Expected_brain_vol_percent)) +
  geom_ribbon(aes(ymax=UCI*Expected_brain_vol_percent, ymin=LCI*Expected_brain_vol_percent), 
              alpha=0.3,
              fill=plasma(4)[2]) +
  geom_line(color="#292829", size=1) +
  geom_vline(xintercept=500, lty=2, , size =1, colour="green") +
  geom_vline(xintercept=600, lty=2, , size =1, colour="green") +
  # scale_y_continuous(position = "right", 
  #                    name="Change in infarct volume (Absolute, % of whole brain)", 
  #                    breaks=seq(-3,1.5,by=0.5),
  #                    sec.axis = sec_axis(~.*Expected_brain_vol_percent, 
  #                                        name="Change in infarct volume (Relative, % of average stroke volume)",
  #                                        breaks=seq(-125,75,by=25))) +
  scale_x_continuous(breaks=seq(475,800,by=50)) +
  scale_y_continuous(breaks=seq(-125,75,by=25)) +
  theme_classic() +
  labs(x = "Light wavelength (nm)",
       y = "% of average infarct volume")+
  #Make ticks black   
  theme(axis.ticks=element_line(color="black", lineend = "square")) 
dev.off()

ggplot(dfc3_Wavelength, aes(x=Light_wavelength, y=Infarct_percent_control)) +
  geom_point() +
  geom_smooth()

hist(dfc3_Wavelength$Light_wavelength)

summary(dfc3_Wavelength$Light_wavelength_cat)

```

```{r Dataframe_prediction_plot_intensity, include=FALSE}

#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Intensity<-expand.grid(Animal = "Rat",
     #Sex ="Male",
     Infarct_time =  24, # start at 4 hours (lowest), go up to 720 (not highest but this is 30 days post-stroke) in 4 hour increments
     Infarct_measurement = "Other histology (ex vivo)",
     #Surgical_level = 'Scalp retracted, skull intact',
     #Comorbidity = "None",
     Isoflurane = 1, #isoflurane is our base anaesthetic
     #Ketamine = 0, #dummy
     #Xylazine = 0, #dummy
     Nitrous_oxide =0, #dummy
     Halothane =0, #dummy
     Chloral_hydrate = 0, #dummy
     Sodium_pentobarbital =0, #dummy
     #Enflurane =0, #dummy
     #Tiletamine_Zolazepam =0, #dummy
     #Anaesthetic_not_reported =0, #dummy
     Other_anaesthetics =0,
     #RB_dose_mgkg_cat ="0.1-15mg/kg", 
     Light_source = "Xenon",
     Light_aperture_cat = "0.02-1mm",
     Light_time_cat= "0.5-5mins", 
     Light_intensity_Wcm2 = seq(0.5, 16, by=0.2), # start at 0.5W/cm2 (min is 0.000249), go up to 16W/cm2 (max is 15.9, almost none that high) in 0.2W/cm2 increments
   weights = 8) #average n of animals = ~8

# generate predicted values from our model
Intensity_predicted_untransformed <- predict(lm_intensity_transformed, 
                                              newdata=grid_Intensity)
# generate lower confidence intervals by subtracting standard errors
Intensity_LCI_untransformed <- Intensity_predicted_untransformed-predict(lm_intensity_transformed, 
                                                                           newdata=grid_Intensity, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Intensity_UCI_untransformed<-Intensity_predicted_untransformed+predict(lm_intensity_transformed, 
                                                                         newdata=grid_Intensity, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Intensity_predicted <- data.frame(grid_Intensity$Light_intensity_Wcm2, 
                                      Intensity_predicted_untransformed^(1/Selected.lambda_intensity),
                                      Intensity_LCI_untransformed^(1/Selected.lambda_intensity),
                                      Intensity_UCI_untransformed^(1/Selected.lambda_intensity))

# Change the column names
colnames(df_Intensity_predicted)<-c("Intensity", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
Intensity.correct<- df_Intensity_predicted[1,2] # Select row 1, column 2, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Intensity_predicted$Infarct_volume<-df_Intensity_predicted$Infarct_volume-Intensity.correct
df_Intensity_predicted$LCI<-df_Intensity_predicted$LCI-Intensity.correct
df_Intensity_predicted$UCI<-df_Intensity_predicted$UCI-Intensity.correct


```

```{r Prediction_plot_intensity, include=FALSE, eval=FALSE}

pdf("Continuous_predicted_intensity_4.pdf", width = 4.5, height = 4)
ggplot(df_Intensity_predicted, aes(x=Intensity, y=Infarct_volume*Expected_brain_vol_percent)) +
  geom_ribbon(aes(ymax=UCI*Expected_brain_vol_percent, ymin=LCI*Expected_brain_vol_percent), 
              alpha=0.3,
              fill=plasma(4)[3]) +
  geom_line(color="#292829", size=1) +
  geom_hline(yintercept=0, lty=2, size =1) +
  scale_x_continuous(breaks=seq(-1,16,by=2)) +
  scale_y_continuous(breaks=seq(-50,850,by=100)) +
  theme_classic() +
  labs(x = "Light intensity (W/cm^2)",
       y = "% of average infarct volume")+
  #Make ticks black   
  theme(axis.ticks=element_line(color="black", lineend = "square"))
dev.off()
```

```{r Dataframe_prediction_plot_Surgery*aperture, include=FALSE}

#make grid of baselines + variable options, selecting the "baseline" for all except variable of interest
grid_Surgical_Aperture<-expand.grid(Animal = "Rat",
     #Sex ="Male",
     Infarct_time =  24, 
     #Comorbidity = "None",
     Infarct_measurement = "Other histology (ex vivo)",
     Surgical_level = levels(dfc3_Surgical_Aperture$Surgical_level),#[c(1,3)], 
     Light_aperture = seq(0.2,6, by = 0.2 ),
     #Light_time_cat= "0.5-5mins", 
     Light_wavelength = 550, 
     Light_source = "Halogen", # had to change from xenon to halogen as more complete cases with halogen
   weights = 8) #average n of animals = ~8


# generate predicted values from our model
Surgical_Aperture_predicted_untransformed <- predict(lm_Surgical_Aperture_Transformed, 
                                              newdata=grid_Surgical_Aperture)
# generate lower confidence intervals by subtracting standard errors
Surgical_Aperture_LCI_untransformed <- Surgical_Aperture_predicted_untransformed-predict(lm_Surgical_Aperture_Transformed, 
                                                                           newdata=grid_Surgical_Aperture, se=T)$se.fit
# generate upper confidence intervals by adding standard errors
Surgical_Aperture_UCI_untransformed<-Surgical_Aperture_predicted_untransformed+predict(lm_Surgical_Aperture_Transformed, 
                                                                         newdata=grid_Surgical_Aperture, se=T)$se.fit
# generate new dataframe for these untransformed predicted values, and transform them
df_Surgical_Aperture_predicted <- data.frame(grid_Surgical_Aperture$Surgical_level, grid_Surgical_Aperture$Light_aperture,
                                      Surgical_Aperture_predicted_untransformed^(1/Selected.lambda_Surgical_Aperture),
                                      Surgical_Aperture_LCI_untransformed^(1/Selected.lambda_Surgical_Aperture),
                                      Surgical_Aperture_UCI_untransformed^(1/Selected.lambda_Surgical_Aperture))

# Change the column names
colnames(df_Surgical_Aperture_predicted)<-c("Surgical_level", "Light_aperture", "Infarct_volume", "LCI", "UCI")
#select the baseline variable infarct volume
Surgical_Aperture.correct<- df_Surgical_Aperture_predicted[1,3] # Select row 1, column 3, which should be the infarct vol of baseline
#minus it from all others to normalise baseline variable to 0 and all others as % change from this
df_Surgical_Aperture_predicted$Infarct_volume<-df_Surgical_Aperture_predicted$Infarct_volume-Surgical_Aperture.correct
df_Surgical_Aperture_predicted$LCI<-df_Surgical_Aperture_predicted$LCI-Surgical_Aperture.correct
df_Surgical_Aperture_predicted$UCI<-df_Surgical_Aperture_predicted$UCI-Surgical_Aperture.correct

df_Surgical_Aperture_predicted$Surgical_level_X_Light_Aperture<-paste(df_Surgical_Aperture_predicted$Surgical_level,
                                                                      df_Surgical_Aperture_predicted$Light_aperture, 
                                                                      sep=" ")

# table(dfc3_Surgical_Aperture$Light_source, dfc3_Surgical_Aperture$Surgical_level) #checking light source complete cases
```

```{r Prediction_plot_Surgery*Aperture, include=FALSE, eval=FALSE}

pdf("Continuous_predicted_Surgery_x_Aperture_5.pdf", width = 6.5, height = 4)

ggplot(df_Surgical_Aperture_predicted, aes(x=Light_aperture, y=Infarct_volume*Expected_brain_vol_percent, 
                                           group=Surgical_level), fill=Surgical_level) +
  geom_line(color="#292829", size=1) +
  geom_hline(yintercept=0, lty=2, size =1) +
  geom_ribbon(aes(ymax=UCI*Expected_brain_vol_percent, ymin=LCI*Expected_brain_vol_percent, fill=Surgical_level), alpha=0.3)+
  scale_fill_manual(values = plasma(10)[c(8,5)])+
  scale_x_continuous(breaks=seq(0,8,by=1)) +
  scale_y_continuous(breaks=seq(-150,200,by=25)) +
  theme_classic() +
  labs(x = "Light aperture (mm)",
       y = "% of average infarct volume") +
  guides(fill=guide_legend(title="Surgical Method")) +
  #Make ticks black   
  theme(axis.ticks=element_line(color="black", lineend = "square"))
dev.off()
```







